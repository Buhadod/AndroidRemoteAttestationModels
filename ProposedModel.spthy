theory AbdullaProtocol
begin

builtins: asymmetric-encryption, signing

/* We formalize the following protocol

 
    1. Server -> App    : N_s
    2. App -> SecWorld  : N_s
    3. SecWorld -> App  : Sign_Sk(N_s,Pk_S) 
    4. App -> Server    : Sign_Sk(N_s,Pk_S)
    5. Server -> DevSvr : Sign_Sk(N_s,Pk_S)
    6. DevSvr -> Server : Sign_Dk(N_s,Pk_S)
    7. Server -> App    : E_PkS(code)
    8. App -> SecWorld  : E_PkS(code)
    9. SecWorld -> App  : code
*/

/*
Assumiption that IMEI is secure (not really in secure world)?

App(codeHash,deviceID, devVerifyKey),  

SecWorldInfoNotRooted(deviceID,IMEI,venderPubKey,SW_signingKey),
SecWorldInfoRooted(deviceID,IMEI,venderPubKey,SW_signingKey),

We assume only one app per developer, for now
DevServerKey(ltkD,pk(ltkD))

VenderServerKeys(venderPrivKey, pk(venderPrivKey), venderSignKey, pk(venderSignKey))

VenderServerInfo(venderPrivKey, venderSignKey, SW_ver_key, IMEI)  <== what if vender has two devs on same device??
VenderServerKnownDevKey(venderPubKey,devPubKey)

NotRooted App  
NotRooted Stopped -> Rooted 
Rooted App 

*/

/* Set up rules */
rule CreateVender:
  [ 
    Fr(~venderPrivKey),
    Fr(~venderSignKey)
  ]
  --[ ]->
  [
    !VenderServerKeys(~venderPrivKey, pk(~venderPrivKey), ~venderSignKey, pk(~venderSignKey))
  ]

rule CreateDevice:
  [ 
    Fr(~deviceID), Fr(~IMEI), Fr(~secWorldSignKey),
    !VenderServerKeys(venderPrivKey, venderPubKey, venderSignKey, venderVerifyKey)
  ]
  --[ ]->
  [
    !SecWorldInfoNotRooted(~deviceID,~IMEI,venderPubKey,~secWorldSignKey),
    !VenderServerInfo(venderPrivKey, venderSignKey, pk(~secWorldSignKey), ~IMEI) 
  ]


  rule CreateDeveloper:
  [ 
    Fr(~devPrivKey), Fr(~devSignKey)
  ]
  --[ Developer(~devPrivKey, pk(~devPrivKey), ~devSignKey, pk(~devSignKey)) ]->
  [
    !DevServerKey(~devPrivKey, pk(~devPrivKey), ~devSignKey, pk(~devSignKey))
  ]

  rule CreateApp:
  [
    Fr(~codeHash), Fr (~secret),
    !DevServerKey(devPrivKey,devPupKey,devSignKey,devVerifyKey),
    !VenderServerKeys(venderPrivKey, venderPubKey, venderSignKey, venderVerifyKey)
  ]
  --[ DevAppLink(~codeHash, ~secret,devPupKey)]->
  [
    !DevApp(~codeHash, ~secret,devPupKey,devVerifyKey,devSignKey, venderPubKey, venderVerifyKey)
  ]


  rule InstallAppDevice:
  [
      !DevApp(codeHash, secret,devPupKey,devVerifyKey,devSignKey, venderPubKey, venderVerifyKey),
      !SecWorldInfoNotRooted(deviceID,IMEI,venderPubKey,secWorldSignKey)
  ]
  --[ 
    InstallAppInDevice(codeHash,devPupKey,venderPubKey,deviceID,IMEI),
    TrustedApp(codeHash,secret,IMEI,deviceID)
   ]->
  [
      !App(codeHash, deviceID,devVerifyKey),
      !VenderServerKnownDevKey(venderPubKey,devPupKey)
  ]
  

/* Protocol rules*/
rule DS_to_App_1:
    [
      Fr(~nd)
    ]
  --[ 
       DevStart(~nd)
    ]->
    [ 
      Out( ~nd ),
      DS_State(~nd)
    ]

rule DS_App_SecW_2:
    [
      In(nd), 
      !App(codeHash, deviceID, devVerifyKey)
    ]
  --[ 
      RequestAttestation(nd,codeHash,deviceID)
    ]->
    [ 
      SecWorld_RequestAtt(nd,codeHash,deviceID)
    ]


rule App_SecW_App_3:
  
  let blob  = aenc(sign (<IMEI, 'NotRooted',nd, codeHash, pk(~sessionPrivKey)>,SW_signingKey), venderPubKey)

  in
    [
       Fr(~sessionPrivKey),
       !SecWorldInfoNotRooted(deviceID,IMEI,venderPubKey,SW_signingKey),
       SecWorld_RequestAtt(nd,codeHash,deviceID)
    ]
  --[ 
      Attestation(nd,codeHash,deviceID)
    ]->
    [ 
      !SecWorldSessionKey(deviceID,~sessionPrivKey),
      SecWorld_Attestation(blob)
    ]


rule SecW_App_DS_4:
    [
      SecWorld_Attestation(blob)
    ]
  --[ AppSend(blob) ]->
    [ 
      Out( blob )
    ]

/* skipping App_DS_VS because its a basic forward */

rule DS_VS_DS_5:
  let 
    blob  = aenc(sign (<IMEI, 'NotRooted',nd, codeHash,sessionPubKey>,SecWorldSignKey), pk(venderPrivKey))
    sigma = sign(<IMEI, 'NotRooted',nd, codeHash,sessionPubKey>, venderSignKey)
  in
    [
      !VenderServerInfo(venderPrivKey, venderSignKey, pk(SecWorldSignKey), IMEI),
      !VenderServerKnownDevKey(venderPubKey,devPubKey),
      In (blob)
    ]
    --[ VenderChecked(IMEI, nd, codeHash, sessionPubKey, devPubKey, blob) ]->
    [ 
      Out(<IMEI, 'NotRooted',nd, codeHash,sessionPubKey,sigma>) 
    ]

rule VS_DS_App_6:
  let 
    sigma = sign(<IMEI, 'NotRooted',nd, codeHash,sessionPubKey>, venderSignKey)
  in
    [
      DS_State(nd),
      !DevServerKey(devPrivKey,devPubKey,devSignKey,devVerifyKey),
      !DevApp(codeHash, secret,devPupKey,devVerifyKey,devSignKey, venderPubKey, pk(venderSignKey)),
      In(<IMEI, 'NotRooted',nd, codeHash,sessionPubKey,sigma>)
    ]
    --[ DevSerSendSec(secret,nd,IMEI,codeHash) ]->
    [ 
      Out( sign( aenc( <secret,codeHash>,sessionPubKey ), devSignKey ) )
    ]


rule DS_App_SecWorld_7:
    let signEncSec = sign(encSec, devSignKey) in
    [
      In(signEncSec),
      !App(codeHash,deviceID, pk(devSignKey) )
    ]
    --[ AppAcceptEncSec(encSec, codeHash, deviceID) ]->
    [
      SecWorldDecReq(encSec,codeHash,deviceID)
    ]

rule App_SecWorld_App_8:
    [
       SecWorldDecReq(aenc(<secret,codeHash>, pk(sessionPrivKey)), codeHash,deviceID),
       !SecWorldInfoNotRooted(deviceID,IMEI,SW_cert,SW_signingKey),
       !SecWorldSessionKey(deviceID,sessionPrivKey)
    ]
    --[ SecWorldSentCode(deviceID,codeHash,secret) ]->
    [
      
    ]


lemma types [sources]:
" All IMEI nd codeHash sessionPubKey devPubKey blob #i.
    VenderChecked(IMEI, nd, codeHash, sessionPubKey, devPubKey, blob) @i
    ==>   ( Ex #j. AppSend(blob) @ j & #j < #i) 
        | ( Ex #k. KU(<IMEI, nd, codeHash, sessionPubKey>) @ k & #k < #i)"

lemma testTrace:
  exists-trace 
  " Ex #i deviceID codeHash secret.
      SecWorldSentCode(deviceID,codeHash,secret) @ i "

lemma onlyTrustedAppsCanGetSecret:
  " All deviceID codeHash secret #i.
      SecWorldSentCode(deviceID,codeHash,secret) @ #i
        ==> (Ex #j IMEI. TrustedApp(codeHash,secret,IMEI,deviceID) @ #j & #j < #i )"

end