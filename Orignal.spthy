theory AbdullaProtocol
begin

builtins: asymmetric-encryption, signing

/* We formalize the following protocol

 
    1. Server -> App    : N_s
    2. App -> SecWorld  : N_s
    3. SecWorld -> App  : Sign_Sk(N_s,Pk_S) 
    4. App -> Server    : Sign_Sk(N_s,Pk_S)
    5. Server -> DevSvr : Sign_Sk(N_s,Pk_S)
    6. DevSvr -> Server : Sign_Dk(N_s,Pk_S)
    7. Server -> App    : E_PkS(code)
    8. App -> SecWorld  : E_PkS(code)
    9. SecWorld -> App  : code
*/

/*
Assumiption that IMEI is secure (not really in secure world)?

App(codeHash,deviceID, devVerifyKey),  

SecWorldInfoNotRooted(deviceID,IMEI,venderPubKey,SW_signingKey),
SecWorldInfoRooted(deviceID,IMEI,venderPubKey,SW_signingKey),

We assume only one app per developer, for now
DevServerAuthedApp(devPubKey,codeHash,IMEI, venderVerifyKey, secret))  <== would need to be expanded for multi dev servers
DevServerKey(ltkD,pk(ltkD))

VenderServerKeys(venderPrivKey, pk(venderPrivKey), venderSignKey, pk(venderSignKey))

VenderServerInfo(venderPrivKey, venderSignKey, SW_ver_key, IMEI)  <== what if vender has two devs on same device??
VenderServerKnownDevKey(venderPubKey,devPubKey)

NotRooted App  
NotRooted Stopped -> Rooted 
Rooted App 

*/

/* Set up rules */
rule CreateVender:
  [ 
    Fr(~venderPrivKey),
    Fr(~venderSignKey)
  ]
  --[ ]->
  [
    !VenderServerKeys(~venderPrivKey, pk(~venderPrivKey), ~venderSignKey, pk(~venderSignKey))
  ]

rule CreateDevice:
  [ 
    Fr(~deviceID), Fr(~IMEI), Fr(~secWorldSignKey),
    !VenderServerKeys(venderPrivKey, venderPubKey, venderSignKey, venderVerifyKey)
  ]
  --[ ]->
  [
    !SecWorldInfoNotRooted(~deviceID,~IMEI,venderPubKey,~secWorldSignKey),
    !VenderServerInfo(venderPrivKey, venderSignKey, pk(~secWorldSignKey), ~IMEI) 
  ]

  //  - This should be expanded to allow the dev to have may apps, and for the same app to be on many phones
  //  - Add dev enc keys to Abdulla's diagram
  rule CreateTrustedDevAndApp:
   [ 
    Fr(~codeHash), Fr (~secret), Fr(~devPrivKey), Fr(~devSignKey),
    !SecWorldInfoNotRooted(deviceID, IMEI, venderPubKey, secWorldSignKey),
    !VenderServerKeys(venderPrivKey, venderPubKey, venderSignKey, venderVerifyKey)
   ]
  --[ TrustedApp(~codeHash,~secret,IMEI,deviceID) ]->
  [
    !App(~codeHash, deviceID, pk(~devSignKey)),  
    !DevServerAuthedApp(pk(~devPrivKey),~codeHash, IMEI, venderVerifyKey, ~secret),
    !DevServerKey(~devPrivKey,pk(~devPrivKey),~devSignKey,pk(~devSignKey)),
    !VenderServerKnownDevKey(venderPubKey,pk(~devPrivKey))
  ]
/* Need to improve this */ 
  rule CreateUntrustedApp:
   [ 
    Fr(~codeHash), Fr(~fakeKey),
    !SecWorldInfoNotRooted(deviceID, IMEI, venderPubKey, secWorldSignKey)
   ]
  --[ UnTrusedApp(~codeHash,IMEI,deviceID) ]->
   [
    !App(~codeHash,deviceID,~fakeKey)  
   ]


/* Protocol rules*/
rule DS_to_App_1:
    [
      Fr(~nd)
    ]
  --[ 
       DevStart(~nd)
    ]->
    [ 
      Out( ~nd ),
      DS_State(~nd)
    ]

rule DS_App_SecW_2:
    [
      In(nd), 
      !App(codeHash, deviceID, devVerifyKey)
    ]
  --[ 
      RequestAttestation(nd,codeHash,deviceID)
    ]->
    [ 
      SecWorld_RequestAtt(nd,codeHash,deviceID)
    ]


rule App_SecW_App_3:
  let appSig = sign(codeHash,SW_signingKey)
      blob   = aenc(<IMEI, 'NotRooted',nd, codeHash, pk(~sessionPrivKey)>, venderPubKey)
      sigma  = sign(blob,SW_signingKey)
  in
    [
       Fr(~sessionPrivKey),
       !SecWorldInfoNotRooted(deviceID,IMEI,venderPubKey,SW_signingKey),
       SecWorld_RequestAtt(nd,codeHash,deviceID)
    ]
  --[ 
      Attestation(nd,codeHash,deviceID)
    ]->
    [ 
      !SecWorldSessionKey(deviceID,~sessionPrivKey),
      SecWorld_Attestation(blob,sigma)
    ]

/*
rule SecW_to_App_1_Rooted:
  let appSig = Sign(codeHash,SW_signingKey)
      blob   = aenc( (IMEI, 'rooted', nd, appSig, sessionPubKey), venderPubKey)
      sigma  = sign(blob,SW_signingKey)
  in
    [
       Fr(~sessionPubKey)
       !SecWorldInfoRooted(deviceID,IMEI,venderPubKey,SW_signingKey),
       In(nd,codeHash),
    ]
  --[ 
      Attestation(nd)
    ]->
    [ 
      SecWorldKey()
      SecWorld_Attestation(blob,sigma),
    ]
*/

rule SecW_App_DS_4:
    [
      SecWorld_Attestation(blob,sigma)
    ]
  --[ AppSend(blob,sigma) ]->
    [ 
      Out( <blob,sigma> )
    ]

/* skipping App_DS_VS because its a basic forward */

rule DS_VS_DS_5:
  let 
    blob   = aenc( <IMEI, 'NotRooted', nd, codeHash, sessionPubKey>, pk(venderPrivKey))
    sigma  = sign(blob, SecWorldSignKey)
    blob2  = aenc( <IMEI, 'NotRooted', nd, codeHash, sessionPubKey>, devPubKey)
    sigma2 = sign(blob2, venderSignKey)
  in
    [
      !VenderServerInfo(venderPrivKey, venderSignKey, pk(SecWorldSignKey), IMEI),
      !VenderServerKnownDevKey(venderPubKey,devPubKey),
      In (<blob,sigma>)
    ]
    --[ VenderChecked(IMEI, nd, codeHash, sessionPubKey, devPubKey, blob, sigma) ]->
    [ 
      Out(<blob2,sigma2>) 
    ]

rule VS_DS_App_6:
  let 
    blob2  = aenc( <IMEI, 'NotRooted', nd, codeHash, sessionPubKey>, devPubKey)
    sigma2 = sign(blob2, venderSignKey)
  in
    [
      DS_State(nd),
      !DevServerKey(devPrivKey,devPubKey,devSignKey,devVerifyKey),
      !DevServerAuthedApp(devPubKey,codeHash,IMEI, pk(venderSignKey),secret),
      In(<blob2,sigma2>)
    ]
    --[ DevSerSendSec(secret,nd,IMEI,codeHash) ]->
    [ 
      Out( sign( aenc( <secret,codeHash>,sessionPubKey ), devSignKey ) )
    ]


rule DS_App_SecWorld_7:
    let signEncSec = sign(encSec, devSignKey) in
    [
      In(signEncSec),
      !App(codeHash,deviceID, pk(devSignKey) )
    ]
    --[ AppAcceptEncSec(encSec, codeHash, deviceID) ]->
    [
      SecWorldDecReq(encSec,codeHash,deviceID)
    ]

rule App_SecWorld_App_8:
    [
       SecWorldDecReq(aenc(<secret,codeHash>, pk(sessionPrivKey)), codeHash,deviceID),
       !SecWorldInfoNotRooted(deviceID,IMEI,SW_cert,SW_signingKey),
       !SecWorldSessionKey(deviceID,sessionPrivKey)
    ]
    --[ SecWorldSentCode(deviceID,codeHash,secret) ]->
    [
      
    ]

//Needed to stop Tamarin going into an infinite loop. 
//See e.g. Chapter 7 of the Tamarin manual. 
lemma types [sources]:
" All IMEI nd codeHash sessionPubKey devPubKey blob sigma #i.
    VenderChecked(IMEI, nd, codeHash, sessionPubKey, devPubKey, blob, sigma) @i
    ==>   ( Ex #j. AppSend(blob,sigma) @ j & #j < #i) 
        | ( Ex #k. KU(<IMEI, nd, codeHash, sessionPubKey>) @ k & #k < #i)"

lemma testTrace:
  exists-trace 
  " Ex #i deviceID codeHash secret.
      SecWorldSentCode(deviceID,codeHash,secret) @ i "

lemma onlyTrustedAppsCanGetSecret:
  " All deviceID codeHash secret #i.
      SecWorldSentCode(deviceID,codeHash,secret) @ #i
        ==> (Ex #j IMEI. TrustedApp(codeHash,secret,IMEI,deviceID) @ #j & #j < #i )"

end
/*

lemma canFinsh:
  exists-trace 
  " Ex #i deviceID secret. SecWorld_Code(deviceID,secret) @ i "
*/

end
