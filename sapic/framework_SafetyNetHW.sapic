/*******************************************************************************
	Remote attestation Framework
	AUTHORS
	
	
*******************************************************************************/

theory Framework_SafetyNetHW
begin

builtins: signing, asymmetric-encryption

functions: check_rep/2,  get_rep/1, rep/2 [private], create_certificate/3, verify_certificate/2 , get_tbsInfo_certificate/1

equations:
    check_rep(rep(x.1, x.2), x.2) = true,
    get_rep(rep(x.1, x.2)) = x.1,

    create_certificate(SubjectTBSCertificateInfo,SubjectPup,IssuerSk) 
      = < SubjectTBSCertificateInfo, SubjectPup, sign(<SubjectTBSCertificateInfo, SubjectPup>,IssuerSk) >,

    verify_certificate( 
    < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
     , < IssuerTBSCertificateInfo, pk(IssuerSk), sign(<IssuerTBSCertificateInfo, pk(IssuerSk)>,IssuerRootSk) >
          ) = true,

    get_tbsInfo_certificate( 
        < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
          ) = SubjectTBSCertificateInfo
      

/***************************************** Knox V2 *****************************************/

let AtServerKV2 =
	!(

		//retrive the blob from the developer server and verfiy it
        [TOAT(sid,rep(<atId,hardwareMeasurement,packagename,appSignature,nonce, deviceId>,<~skAT,'Trustzone'>))]--[]-> [];

		//create a verdict  and send it to the developer server
		let verdict = <atId,hardwareMeasurement,packagename,appSignature,nonce, deviceId> in
		event Ats_at(atId,hardwareMeasurement, nonce);
		
        []--[]-> [FRAT(sid,verdict)];

		event T_finish() 
	)

let KnoxV2TA =

	!(
		//receve an application + nonce
		in(<nonce,packagename,content,sign(key,<packagename,content>)>);
		
		new ~atId;
		event Attestating_App(~atId,packagename,sign(key,<packagename,content>),~deviceId);

		if(status = 'tamper') then
			let hardwareMeasurement = 'invalid' in
			let softwareMeasurement = customSoftwareMeasurement in
			let blob = rep(<~atId,hardwareMeasurement,packagename,sign(key,<packagename,content>),nonce, ~deviceId>,<~skAT,'Trustzone'>) in 
			//send attestation report to the app
			event DeviceStatus(~atId,~deviceId,hardwareMeasurement);
			out(blob);
			event S_finish();
			0
		else
			let hardwareMeasurement = 'valid' in
			let softwareMeasurement = 'valid' in
			let blob = rep(<~atId,hardwareMeasurement,packagename,sign(key,<packagename,content>),nonce, ~deviceId>,<~skAT,'Trustzone'>) in 
			//send attestation report to the app
			event DeviceStatus(~atId,~deviceId,hardwareMeasurement);
			out(blob);
			event S_finish();
			0
			
	)
	

let DevServerKV2 =


	//creating and publising the application
	new ~advk;
	new ~content;
	new ~packagename;
	let appSignature = sign(~advk, <~packagename,~content>) in
	let app = <~packagename,~content,appSignature> in
	out(app);
	event App_Created(~packagename,appSignature);
	
	!(
	
		// create a nonce
		new ~nonce;
		event NonceGenerated(~nonce);
		out(~nonce);
		
		//retrive blob from clients
		in(blob);
		
		//create developer-attesation server session id, to keep track or pair of request-response message  
		new ~sid;
		//send blob to the attestation server
		[]--[]-> [TOAT(~sid,blob)];
		
		//retreive the verfied report the attestation server, pattern matching is used for checking the status
		[FRAT(~sid,<atId,hardwareMeasurement,fpackagename,fappSignature,~nonce, deviceId>)]--[]-> [];
		
		//attestation finished
		//in knoxv2 app checking is always valid. while in other, we use if statment to check.

		//event Dev_app(atId,~packagename,appSignature,deviceId);
		//event Verdict_app(atId,deviceId,hardwareMeasurement,'valid');

		
		if not(appSignature = fappSignature) | not(~packagename = fpackagename)  then
			event Verdict_app(atId,deviceId,hardwareMeasurement,'invalid');
			event D_finish() 
		else
			event Verdict_app(atId,deviceId,hardwareMeasurement,'valid');
			event D_finish() 
		
		
		
	)



/*************************************** Generic code *************************************************/
	
// Main process starts here

/***************************************** choose a platofrm ***************************************************
* platform				|		SafetyNet			|		KnoxV2		|	KnoxV3			|	Key Attestation
* --------------------------------------------------------------------------------------------------------------
* AttestationAgent		: GooglePlay | SafetyNetTA	|	KnoxV2TA		|	KnoxV3TA		|	KeyMasterTA
* AtServer				:		AtServerSN			|	AtServerKV2		|	AtServerKV3		|	AtServerKA
* DevServer				:		DevServerSN			|	DevServerKV2	|	DevServerKV3	|	DevServerKA
***************************************************************************************************************/


let AttestationAgent =
	KnoxV2TA

let AtServer = 
	AtServerKV2

let DevServer = 
	DevServerKV2


let Device =

	//Create device reference
	new ~deviceId;

	//receive an adversary's attempt to compomised the device
	in(<status,customSoftwareMeasurement>);

	//send the device refernece , allows an advsery to tamper the device
	out(~deviceId);

	AttestationAgent



//create pair attetsation keys to be used by secreworld for sigining, and attestation server for verfication
new ~skAT;
let pkAT = pk(~skAT) in


(!Device || !DevServer || AtServer)

lemma Correctness_D:
exists-trace
	"Ex atId deviceId #i. Verdict_app(atId,deviceId,'valid','valid')@i"

/*
lemma types [sources]:
	"(All secret #i. SecretReceived(secret) @ i ==> 
	( 
	(Ex #j. KU(secret) @ j & j < i) 
	| (Ex #j. SecretGenerated( secret ) @ j)
	))"
*/
// for all valid attestation => (device must be not rooted and app must be not repacked).
// move deviceStatus to secureworld.
lemma SecretSecrecy:
	"(All atId deviceId #i. Verdict_app(atId,deviceId,'valid','valid') @ i ==> 
	( 
	(Ex #j. DeviceStatus(atId,deviceId,'valid') @ j & j < i) 
	& (Ex packagename appSignature #j #k. 
			 App_Created(packagename,appSignature) @ j 
			 & Attestating_App(atId,packagename,appSignature,deviceId)@ k)
	))"

/*
lemma SecretSecrecy: 
        "(not ( Ex secret #i #k. SecretGenerated(secret) @i & KU(secret) @k ))"

lemma ApplicationIntegrity:
	"(not ( Ex secret appId #i #k. SecretGenerated(secret) @i & ApplicationTampered(appId,secret) @k ))"

lemma DeviceIntegrity:
	"(not ( Ex secret deviceId #i #k. SecretGenerated(secret) @i & DeviceTampered(deviceId,secret) @k ))"

lemma UniqueNonce:
	"All n #i #j. NonceGenerated(n) @i & NonceGenerated(n) @j ==> #i=#j"

//Sanity check: Developer server finsihed
lemma Correctness_D:
exists-trace
	"Ex #i. D_finish()@i"

//Sanity check: Secure world/device Finished
lemma Correctness_S:
exists-trace
	"Ex #i. S_finish()@i"
	
//Sanity check: Attesation server finished
lemma Correctness_T:
exists-trace
	"Ex #i. T_finish()@i"
	*/
end