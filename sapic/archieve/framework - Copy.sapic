/*******************************************************************************
	Remote attestation Framework
	AUTHORS
	
	
*******************************************************************************/

theory Framework
begin

builtins: signing, asymmetric-encryption

functions: check_rep/2,  get_rep/1, rep/2 [private], create_certificate/3, verify_certificate/2 , get_tbsInfo_certificate/1

equations:
    check_rep(rep(x.1, x.2), x.2) = true,
    get_rep(rep(x.1, x.2)) = x.1,

    create_certificate(SubjectTBSCertificateInfo,SubjectPup,IssuerSk) 
      = < SubjectTBSCertificateInfo, SubjectPup, sign(<SubjectTBSCertificateInfo, SubjectPup>,IssuerSk) >,

    verify_certificate( 
    < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
     , < IssuerTBSCertificateInfo, pk(IssuerSk), sign(<IssuerTBSCertificateInfo, pk(IssuerSk)>,IssuerRootSk) >
          ) = true,

    get_tbsInfo_certificate( 
        < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
          ) = SubjectTBSCertificateInfo
      

/***************************************** SafetyNet *****************************************/

let AtServerSN =
	!(

		//retrive the blob from the developer server and verfiy it
        [TOAT(sid,rep(<Measurement,nonce,packagename,appSignature, deviceId>,<~skAT,'Trustzone'>))]--[]-> [];

		//create a verdict  and send it to the developer server
		let verdict = <Measurement,nonce,packagename,appSignature, deviceId> in
        []--[]-> [FRAT(sid,verdict)];

		event T_finish() 
	)

let DevServerSN =

	//creating and publising the application
	new ~advk;
	new ~content;
	new ~packagename;
	let appSignature = sign(~advk, <~packagename,~content>) in
	let app = <~packagename,~content,appSignature> in
	out(app);

	//create a developer's pair key for secure cominucaion with clients
	new ~dvk;
	let dbpk = pk(~dvk) in

	//send it public key publically, allows advsery to cominuncate with the developer server
	out(dbpk);

	//send the publick key privatley for  client who request it by URL (authetnication)
	[]--[]-> [GetDeveloperkey(pk(~dvk),appSignature)];
	
	//create a secret to be sent inexchange for a valid report
	new ~secret;
	event SecretGenerated(~secret);


	!(
		// create a nonce
		new ~nonce;
		event NonceGenerated(~nonce);
		// retrive clients' session key
		in(aenc(dbpk,<'nonce_request',ask>));
		//send nonce to to clients encrypted with their session key
		out(aenc(ask,<'nonce_response',~nonce>));


		//retrive blob from clients
		in(aenc(dbpk,<'blob_request',ask,blob>));


		//create developer-attesation server session id, to keep track or pair of request-response message  
		new ~sid;
		//send blob to the attestation server
		[]--[]-> [TOAT(~sid,blob)];
		//retreive the verfied report the attestation server, pattern matching is used for checking the status
		[FRAT(~sid,<'valid',~nonce,~packagename,appSignature, deviceId>)]--[]-> [];

		
		out(aenc(ask,<'blob_response',~secret>));

		event D_finish() 
	)

/***************************************** SafetyNet SW *****************************************/

let GooglePlay =

	!(
		//recieve nonce from the App
		[AndroidIntentTOSW(asid,~deviceId,nonce,packagename,appSignature)]--[]-> [];

		if(status = 'tamper') then
			let hardwareMeasurement = 'invalid' in
			let softwareMeasurement = customSoftwareMeasurement in
			let blob = rep(<softwareMeasurement,nonce,packagename,appSignature, ~deviceId>,<~skAT,'Trustzone'>) in 
			//send attestation report to the app
			[]--[]-> [AndroidIntentFRSW(asid,hardwareMeasurement,blob)];
			event S_finish();
			0
		else
			let hardwareMeasurement = 'valid' in
			let softwareMeasurement = 'valid' in
			let blob = rep(<softwareMeasurement,nonce,packagename,appSignature, ~deviceId>,<~skAT,'Trustzone'>) in 
			//send attestation report to the app
			[]--[]-> [AndroidIntentFRSW(asid,hardwareMeasurement,blob)];
			event S_finish()
	)
		
	

/***************************************** SafetyNet HW *****************************************/

let SafetyNetTA =

	!(
		//recieve nonce from the App
		[AndroidIntentTOSW(asid,~deviceId,nonce,packagename,appSignature)]--[]-> [];

		if(status = 'tamper') then
			let hardwareMeasurement = 'invalid' in
			let softwareMeasurement = customSoftwareMeasurement in
			let blob = rep(<hardwareMeasurement,nonce,packagename,appSignature, ~deviceId>,<~skAT,'Trustzone'>) in 
			//send attestation report to the app
			[]--[]-> [AndroidIntentFRSW(asid,hardwareMeasurement,blob)];
			event S_finish();
			0
		else
			let hardwareMeasurement = 'valid' in
			let softwareMeasurement = 'valid' in
			let blob = rep(<hardwareMeasurement,nonce,packagename,appSignature, ~deviceId>,<~skAT,'Trustzone'>) in 
			//send attestation report to the app
			[]--[]-> [AndroidIntentFRSW(asid,hardwareMeasurement,blob)];
			event S_finish()
	)

/***************************************** Knox V2 *****************************************/

let AtServerKV2 =
	!(

		//retrive the blob from the developer server and verfiy it
        [TOAT(sid,rep(<hardwareMeasurement,nonce, deviceId>,<~skAT,'Trustzone'>))]--[]-> [];

		//create a verdict  and send it to the developer server
		let verdict = <hardwareMeasurement,nonce, deviceId> in
        []--[]-> [FRAT(sid,verdict)];

		event T_finish() 
	)

let KnoxV2TA =

	!(
		//recieve nonce from the App
		[AndroidIntentTOSW(asid,~deviceId,nonce,packagename,appSignature)]--[]-> [];

		if(status = 'tamper') then
			let hardwareMeasurement = 'invalid' in
			let softwareMeasurement = customSoftwareMeasurement in
			let blob = rep(<hardwareMeasurement,nonce, ~deviceId>,<~skAT,'Trustzone'>) in 
			//send attestation report to the app
			[]--[]-> [AndroidIntentFRSW(asid,hardwareMeasurement,blob)];
			event S_finish();
			0
		else
			let hardwareMeasurement = 'valid' in
			let softwareMeasurement = 'valid' in
			let blob = rep(<hardwareMeasurement,nonce, ~deviceId>,<~skAT,'Trustzone'>) in 
			//send attestation report to the app
			[]--[]-> [AndroidIntentFRSW(asid,hardwareMeasurement,blob)];
			event S_finish()
	)
	

let DevServerKV2 =

	//creating and publising the application
	new ~advk;
	new ~content;
	new ~packagename;
	let appSignature = sign(~advk, <~packagename,~content>) in
	let app = <~packagename,~content,appSignature> in
	out(app);

	//create a developer's pair key for secure cominucaion with clients
	new ~dvk;
	let dbpk = pk(~dvk) in

	//send it public key publically, allows advsery to cominuncate with the developer server
	out(dbpk);

	//send the publick key privatley for  client who request it by URL (authetnication)
	[]--[]-> [GetDeveloperkey(pk(~dvk),appSignature)];
	
	//create a secret to be sent inexchange for a valid report
	new ~secret;
	event SecretGenerated(~secret);

	!(
		// create a nonce
		new ~nonce;
		event NonceGenerated(~nonce);

		// retrive clients' session key
		in(aenc(dbpk,<'nonce_request',ask>));
		//send nonce to to clients encrypted with their session key
		out(aenc(ask,<'nonce_response',~nonce>));


		//retrive blob from clients
		in(aenc(dbpk,<'blob_request',ask,blob>));


		//create developer-attesation server session id, to keep track or pair of request-response message  
		new ~sid;
		//send blob to the attestation server
		[]--[]-> [TOAT(~sid,blob)];
		//retreive the verfied report the attestation server, pattern matching is used for checking the status
		[FRAT(~sid,<'valid',~nonce, deviceId>)]--[]-> [];

		
		out(aenc(ask,<'blob_response',~secret>));

		event D_finish() 
	)


/***************************************** Knox V3 *************************************************/

let KnoxV3TA =
	
	!(
		//recieve nonce from the App
		[AndroidIntentTOSW(asid,~deviceId,nonce,packagename,appSignature)]--[]-> [];

		new ~tsid;

		if(status = 'tamper') then
			let hardwareMeasurement = 'invalid' in
			let softwareMeasurement = customSoftwareMeasurement in
			let blob = rep(<hardwareMeasurement,nonce,packagename,appSignature, ~deviceId>,<~skAT,'Trustzone'>) in 
			///send attestation report to the attestation server
			[]--[]-> [HttpsToAt(~tsid,blob)];
			[HttpsFromAT(~tsid,hid)]--[]-> [];
			//send hid to the app
			[]--[]-> [AndroidIntentFRSW(asid,hardwareMeasurement,hid)];
			event S_finish();
			0
		else
			let hardwareMeasurement = 'valid' in
			let softwareMeasurement = 'valid' in
			let blob = rep(<hardwareMeasurement,nonce,packagename,appSignature, ~deviceId>,<~skAT,'Trustzone'>) in 
			//send attestation report to the attestation server
			[]--[]-> [HttpsToAt(~tsid,blob)];
			[HttpsFromAT(~tsid,hid)]--[]-> [];
			//send hid to the app
			[]--[]-> [AndroidIntentFRSW(asid,hardwareMeasurement,hid)];
			event S_finish()
	)
	

let AtServerKV3 = 
	!(
		//Retrive blob
		[HttpsToAt(tsid,rep(<hardwareMeasurement,nonce,packagename,appSignature, deviceId>,<~skAT,'Trustzone'>))]--[]-> [];

		//refernce blob to an hid
		new ~hid;
		//Send hid for the TZ
		[]--[]-> [HttpsFromAT(tsid,~hid)];
		
		//Retrive hid from the developer server and verfiy it
        [TOAT(sid,~hid)]--[]-> [];

		//create a verdict  and send it to the developer server
		let verdict = <hardwareMeasurement,nonce,packagename,appSignature, deviceId> in
        []--[]-> [FRAT(sid,verdict)];

		event T_finish() 
	)

let DevServerKV3 = 
	//creating and publising the application
	new ~advk;
	new ~content;
	new ~packagename;
	let appSignature = sign(~advk, <~packagename,~content>) in
	let app = <~packagename,~content,appSignature> in
	out(app);

	//create a developer's pair key for secure cominucaion with clients
	new ~dvk;
	let dbpk = pk(~dvk) in

	//send it public key publically, allows advsery to cominuncate with the developer server
	out(dbpk);

	//send the publick key privatley for  client who request it by URL (authetnication)
	[]--[]-> [GetDeveloperkey(pk(~dvk),appSignature)];
	
	//create a secret to be sent inexchange for a valid report
	new ~secret;
	event SecretGenerated(~secret);


	!(
		// create a nonce
		new ~nonce;
		event NonceGenerated(~nonce);

		// retrive clients' session key
		in(aenc(dbpk,<'nonce_request',ask>));
		//send nonce to to clients encrypted with their session key
		out(aenc(ask,<'nonce_response',~nonce>));


		//retrive hid from clients
		in(aenc(dbpk,<'blob_request',ask,hid>));


		//create developer-attesation server session id, to keep track or pair of request-response message  
		new ~sid;
		//send hid to the attestation server
		[]--[]-> [TOAT(~sid,hid)];
		//retreive the verfied report the attestation server, pattern matching is used for checking the status
		[FRAT(~sid,<'valid',~nonce,~packagename,appSignature, deviceId>)]--[]-> [];

		
		out(aenc(ask,<'blob_response',~secret>));

		event D_finish() 
	)


/***************************************** Key Attestation *****************************************/


let KeyMasterTA =

	//Request attestation server
	[!RequestCreatingIntermediateCertificate(rootSk,rootCertificate)]--[]->[];
	
	//Create keymaster certficate
	new ~keymasterSk;
	let  intermediateCertificate = create_certificate('TbsKeyStoreInfo',pk(~keymasterSk),rootSk) in

	!(
		//recieve nonce from the App
		[AndroidIntentTOSW(asid,~deviceId,nonce,packagename,appSignature)]--[]->[];
		
		new ~key;
		let subjectCertificate = create_certificate(<hardwareMeasurement,nonce,packagename,appSignature>,pk(~key),~keymasterSk) in
		let certificateChain = <subjectCertificate, intermediateCertificate, rootCertificate> in 

		if(status = 'tamper') then
			let hardwareMeasurement = 'invalid' in
			let softwareMeasurement = customSoftwareMeasurement in
			let subjectCertificate = create_certificate(<hardwareMeasurement,nonce,packagename,appSignature>,pk(~key),~keymasterSk) in
			let certificateChain = <subjectCertificate, intermediateCertificate, rootCertificate> in 
			//send attestation report to the app
			[]--[]->[AndroidIntentFRSW(asid,hardwareMeasurement,certificateChain)];
			event S_finish();
			0
		else
			let hardwareMeasurement = 'valid' in
			let softwareMeasurement = 'valid' in
			let subjectCertificate = create_certificate(<hardwareMeasurement,nonce,packagename,appSignature>,pk(~key),~keymasterSk) in
			let certificateChain = <subjectCertificate, intermediateCertificate, rootCertificate> in 
			//send attestation report to the app
			[]--[]->[AndroidIntentFRSW(asid,hardwareMeasurement,certificateChain)];
			event S_finish()
	)
		
	

let DevServerKA =

	//creating and publising the application
	new ~advk;
	new ~content;
	new ~packagename;
	let appSignature = sign(~advk, <~packagename,~content>) in
	let app = <~packagename,~content,appSignature> in
	out(app);

	//create a developer's pair key for secure cominucaion with clients
	new ~dvk;
	let dbpk = pk(~dvk) in

	//send it public key publically, allows advsery to cominuncate with the developer server
	out(dbpk);

	//send the publick key privatley for  client who request it by URL (authetnication)
	[]--[]->[GetDeveloperkey(pk(~dvk),appSignature)];
	
	//create a secret to be sent inexchange for a valid report
	new ~secret;
	event SecretGenerated(~secret);


	!(
		// create a nonce
		new ~nonce;
		event NonceGenerated(~nonce);

		// retrive clients' session key
		in(aenc(dbpk,<'nonce_request',ask>));
		//send nonce to to clients encrypted with their session key
		out(aenc(ask,<'nonce_response',~nonce>));


		//retrive blob from clients
		in(aenc(dbpk,<'blob_request',ask,<subjectCertificate, intermediateCertificate, rootCertificate>>));

		[!GetRootCertificate(rootCertificate)]--[]->[];
		
		let verification1 = verify_certificate(subjectCertificate, intermediateCertificate) in
		let verification2 = verify_certificate(intermediateCertificate, rootCertificate) in
		let verification3 = verify_certificate(rootCertificate, rootCertificate) in
		let tbsInfo = get_tbsInfo_certificate(subjectCertificate) in 
		
		new ~vsid;
		[]--[]->[VerficationCertificatehain('verification',<~vsid,verification1,verification2,verification3,<tbsInfo>>)];
		[VerficationCertificatehain('verification',<~vsid,true,true,true,<'valid',~nonce,~packagename,appSignature>>)]--[]->[];
		out(aenc(ask,<'blob_response',~secret>));

		event D_finish() 
	)
	

let AtServerKA =
	new ~rootSk;
	let rootCertificate = create_certificate('TbsInfo',pk(~rootSk),~rootSk) in

	//share root certficate	
	[]--[]->
	[
		!RequestCreatingIntermediateCertificate(~rootSk,rootCertificate),
		!GetRootCertificate(rootCertificate)
	];

	!(
		event T_finish() 
	)




/*************************************** Generic code *************************************************/


let AppCode =
		//Create a session key to cominictae with the developer securely
		new ~ask;

		//request a nonce from the developer server
		out(aenc(dvpk,<'nonce_request',~ask>));

		//retreive a nonoce from the developer server
		in(aenc(~ask,<'nonce_response',nonce>));

		//create a android intent session id, to keep track of the intent session during cominication with attestation agent in the TEE 
		new ~asid;

		//Send nonce to attestation agent and request measuring the device status 
		[]--[]-> [AndroidIntentTOSW(~asid,deviceId,nonce,packagename,sign(key,<packagename,content>))];

		//retrive a blob represent the device measurment
		[AndroidIntentFRSW(~asid,hardwareMeasurement,blob)]--[]-> [];

		//send the blob to the developer server 
		out(aenc(dvpk,<'blob_request',~ask,blob>));

		//retrive the secret from the developer server as a response from sending blob
		in(aenc(~ask,<'blob_response',secret>));

		event SecretReceived(secret);
		event SecretReceivedToApp(secret,~appId);
		event SecretReceivedToDevice(secret,deviceId);

		event A_finish();
		
		//leak secret if app repacked
		if not(appSignature = sign(key,<packagename,content>)) then
			event ApplicationTampered(~appId,secret);
			event DeviceTampered(deviceId,secret);
			event AXA_finish();			
			out(secret)
		else
			//leak if device tampered 
			if(hardwareMeasurement = 'invalid') then
				event DeviceTampered(deviceId,secret);
				event AXR_finish();
				out(secret)
			else
				event AA_finish()
	
// Main process starts here

/***************************************** choose a platofrm ***************************************************
* platform				|		SafetyNet			|		KnoxV2		|	KnoxV3			|	Key Attestation
* --------------------------------------------------------------------------------------------------------------
* AttestationAgent		: GooglePlay | SafetyNetTA	|	KnoxV2TA		|	KnoxV3TA		|	KeyMasterTA
* AtServer				:		AtServerSN			|	AtServerKV2		|	AtServerKV3		|	AtServerKA
* DevServer				:		DevServerSN			|	DevServerKV2	|	DevServerKV3	|	DevServerKA
***************************************************************************************************************/


let AttestationAgent =
	KnoxV3TA

let AtServer = 
	AtServerKV3

let DevServer = 
	DevServerKV3


let Device =

	//Create device reference
	new ~deviceId;

	//receive an adversary's attempt to compomised the device
	in(<status,customSoftwareMeasurement>);

	//request install app in device
	[]--[]-> [!GetDeviceId(~deviceId)];

	//send the device refernece , allows an advsery to tamper the device
	out(~deviceId);

	AttestationAgent


let App =

	new ~appId;
	//install an application
	in(<packagename,content,sign(key,<packagename,content>)>);

	//install app in a device
	[!GetDeviceId(deviceId)]--[]-> [];

	//retrive the developer channel public key for secure coumincation
	[GetDeveloperkey(dvpk,appSignature)]--[]-> [];
	
	!AppCode

//create pair attetsation keys to be used by secreworld for sigining, and attestation server for verfication
new ~skAT;
let pkAT = pk(~skAT) in


(!Device ||!App || !DevServer || AtServer)

lemma types [sources]:
	"(All secret #i. SecretReceived(secret) @ i ==> 
	( 
	(Ex #j. KU(secret) @ j & j < i) 
	| (Ex #j. SecretGenerated( secret ) @ j)
	))"

lemma SecretSecrecy: 
        "(not ( Ex secret #i #k. SecretGenerated(secret) @i & KU(secret) @k ))"

lemma ApplicationIntegrity:
	"(not ( Ex secret appId #i #k. SecretGenerated(secret) @i & ApplicationTampered(appId,secret) @k ))"

lemma DeviceIntegrity:
	"(not ( Ex secret deviceId #i #k. SecretGenerated(secret) @i & DeviceTampered(deviceId,secret) @k ))"

lemma UniqueNonce:
	"All n #i #j. NonceGenerated(n) @i & NonceGenerated(n) @j ==> #i=#j"

//Sanity check: Developer server finsihed
lemma Correctness_D:
exists-trace
	"Ex #i. D_finish()@i"

//Sanity check: Secure world/device Finished
lemma Correctness_S:
exists-trace
	"Ex #i. S_finish()@i"

//Sanity check: Application finished
lemma Correctness_A:
exists-trace
	"Ex #i. A_finish()@i"

//Sanity check: Application Finshed with no tampere
lemma Correctness_AA:
exists-trace
	"Ex #i. AA_finish()@i"

//Sanity check: Application Finshed with app tampered 
lemma Correctness_AXA:
exists-trace
	"Ex #i. AXA_finish()@i"

//Sanity check: Application Finshed with device tampered
lemma Correctness_AXR:
exists-trace
	"Ex #i. AXR_finish()@i"
	
//Sanity check: Attesation server finished
lemma Correctness_T:
exists-trace
	"Ex #i. T_finish()@i"
end