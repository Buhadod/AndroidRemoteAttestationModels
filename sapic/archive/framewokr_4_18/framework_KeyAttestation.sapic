/*******************************************************************************
	Remote attestation Framework
	AUTHORS
	
	
*******************************************************************************/

theory Framework_KeyAttestation
begin

builtins: signing, asymmetric-encryption

functions: check_rep/2,  get_rep/1, rep/2 [private], create_certificate/3, verify_certificate/2 , get_tbsInfo_certificate/1

equations:
    check_rep(rep(x.1, x.2), x.2) = true,
    get_rep(rep(x.1, x.2)) = x.1,

    create_certificate(SubjectTBSCertificateInfo,SubjectPup,IssuerSk) 
      = < SubjectTBSCertificateInfo, SubjectPup, sign(<SubjectTBSCertificateInfo, SubjectPup>,IssuerSk) >,

    verify_certificate( 
    < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
     , < IssuerTBSCertificateInfo, pk(IssuerSk), sign(<IssuerTBSCertificateInfo, pk(IssuerSk)>,IssuerRootSk) >
          ) = true,

    get_tbsInfo_certificate( 
        < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
          ) = SubjectTBSCertificateInfo
      

/***************************************** SafetyNet HW *****************************************/

let AtServerKA =
	new ~rootSk;
	let rootCertificate = create_certificate('TbsInfo',pk(~rootSk),~rootSk) in

	//share root certficate	
	[]--[]->
	[
		!RequestCreatingIntermediateCertificate(~rootSk,rootCertificate),
		!GetRootCertificate(rootCertificate)
	];

	!(
		event T_finish() 
	)

let KeyMasterTA =

	//Request attestation server
	[!RequestCreatingIntermediateCertificate(rootSk,rootCertificate)]--[]->[];
	
	//Create keymaster certficate
	new ~keymasterSk;
	let  intermediateCertificate = create_certificate('TbsKeyStoreInfo',pk(~keymasterSk),rootSk) in

	!(
		//retrieve an application + nonce
		in(<nonce,packagename,content,sign(keyApp,<packagename,content>)>);
		
		new ~key;

		new ~atId;
		event Attestating_App(~atId,packagename,sign(keyApp,<packagename,content>),~deviceId);

		if(status = 'tamper') then
			let hardwareMeasurement = 'invalid' in
			let softwareMeasurement = customSoftwareMeasurement in
			let subjectCertificate = create_certificate(<~atId,hardwareMeasurement,nonce,packagename,sign(keyApp,<packagename,content>),~deviceId>,pk(~key),~keymasterSk) in
			let certificateChain = <subjectCertificate, intermediateCertificate, rootCertificate> in 
			//send attestation report to the app
			event DeviceStatus(~atId,~deviceId,hardwareMeasurement);
			out(certificateChain);
			event S_finish();
			0
		else
			let hardwareMeasurement = 'valid' in
			let softwareMeasurement = 'valid' in
			let subjectCertificate = create_certificate(<~atId,hardwareMeasurement,nonce,packagename,sign(keyApp,<packagename,content>),~deviceId>,pk(~key),~keymasterSk) in
			let certificateChain = <subjectCertificate, intermediateCertificate, rootCertificate> in 
			//send attestation report to the app
			event DeviceStatus(~atId,~deviceId,hardwareMeasurement);
			out(certificateChain);
			event S_finish();
			0
			
	)
	

let DevServerKA =

	//creating and publising the application
	new ~advk;
	new ~content;
	new ~packagename;
	let appSignature = sign(~advk, <~packagename,~content>) in
	let app = <~packagename,~content,appSignature> in
	out(app);
	event App_Created(~packagename,appSignature);
	
	!(
	
		// create a nonce
		new ~nonce;
		event NonceGenerated(~nonce);
		out(~nonce);
		
		//retrieve blob from clients
		in(<subjectCertificate, intermediateCertificate, rootCertificate>);
		
		[!GetRootCertificate(rootCertificate)]--[]->[];

		let verification1 = verify_certificate(subjectCertificate, intermediateCertificate) in
		let verification2 = verify_certificate(intermediateCertificate, rootCertificate) in
		let verification3 = verify_certificate(rootCertificate, rootCertificate) in
		let tbsInfo = get_tbsInfo_certificate(subjectCertificate) in 

		//local verfication for key attestation chain
		new ~vsid;
		[]--[]->[VerficationCertificatehain('verification',<~vsid,verification1,verification2,verification3,<tbsInfo>>)];
		[VerficationCertificatehain('verification',<~vsid,true,true,true,<atId,hardwareMeasurement,~nonce,fpackagename,fappSignature,deviceId>>)]--[]->[];
	
		//attestation finished		
		if not(appSignature = fappSignature) | not(~packagename = fpackagename)  then
			event Verdict_app(atId,deviceId,hardwareMeasurement,'invalid');
			event D_finish() 
		else
			event Verdict_app(atId,deviceId,hardwareMeasurement,'valid');
			event D_finish() 
		
		
		
	)



/*************************************** Generic code *************************************************/
	
// Main process starts here

/***************************************** choose a platofrm ***************************************************
* platform				|		SafetyNet			|		KnoxV2		|	KnoxV3			|	Key Attestation
* --------------------------------------------------------------------------------------------------------------
* AttestationAgent		: GooglePlay | SafetyNetTA	|	KnoxV2TA		|	KnoxV3TA		|	KeyMasterTA
* AtServer				:		AtServerSN			|	AtServerKV2		|	AtServerKV3		|	AtServerKA
* DevServer				:		DevServerSN			|	DevServerKV2	|	DevServerKV3	|	DevServerKA
***************************************************************************************************************/


let AttestationAgent =
	KeyMasterTA

let AtServer = 
	AtServerKA

let DevServer = 
	DevServerKA


let Device =

	//Create device reference
	new ~deviceId;

	//retrieve an adversary's attempt to compomised the device
	in(<status,customSoftwareMeasurement>);

	//send the device refernece , allows an advsery to tamper the device
	out(~deviceId);

	AttestationAgent



//create pair attetsation keys to be used by secreworld for sigining, and attestation server for verfication
new ~skAT;
let pkAT = pk(~skAT) in


(!Device || !DevServer || AtServer)

// for all valid attestation => (device must be not rooted and app must be not repacked).
lemma DeviceAndAppIntegrity:
	"(All atId deviceId #i. Verdict_app(atId,deviceId,'valid','valid') @ i ==> 
	( 
	(Ex #j. DeviceStatus(atId,deviceId,'valid') @ j & j < i) 
	& (Ex packagename appSignature #j #k. 
			 App_Created(packagename,appSignature) @ j 
			 & Attestating_App(atId,packagename,appSignature,deviceId)@ k)
	))"

//Sanity check: Attestation finished
lemma Correctness_AT:
exists-trace
	"Ex atId deviceId #i. Verdict_app(atId,deviceId,'valid','valid') @ i"

end