/*******************************************************************************
	Knox v2
	AUTHORS
	
	Sample message using SAPIC
	

	Protocol:
	1. C -> S: aenc(k, pkS)
	2. C <- S: h(k)

	Notation:
	
	pmk = Pairwise Master Key
	ptk = Pairwise Transient Key, composed of:
		kck = Key Confirmation Key
		kek = Key Encryption Key
		tk = Temporal Key
	gtk = Group Temporal Key
	
	A_  = Events only in authenticator process
	S_  = Events only in supplicant process
	
*******************************************************************************/

theory KnoxV2SAPIC_full
begin

builtins: signing, asymmetric-encryption

functions: check_rep/2,  get_rep/1, rep/2 [private]

equations:
    check_rep(rep(x.1, x.2), x.2) = true,
    get_rep(rep(x.1, x.2)) = x.1

let DeviceTamper =
    in(deviceId);
    lock <'device', deviceId>;
    insert <'device', deviceId>, 'invalid';
    event DeviceTampered(deviceId);
    unlock <'device',deviceId>;
    0

let RepackApp =
    in(appid);
    lock <'app', appid>;
    insert <'app', appid>, 'invalid';
    event AppRepacked(appid);
    unlock <'app',appid>;
    0
      

let SecureWorld =

	//Create device reference
	new ~deviceId;

	//send the device refernece , allows an advsery to tamper the device
	out(~deviceId);

	// intitate the device status with valid state
	lock <'device', ~deviceId>;
    insert <'device', ~deviceId>, 'valid';
    unlock <'device',~deviceId>;


	
	!(
		//lock the device before starting the protocol, as unlocking bootloader reqiure rebooting
		lock <'device', ~deviceId>;

		//recieve nonce from the App
		[AndroidIntentTOSW(asid,nonce)]--[]-> [];

		//create attestation report
		lookup <'device', ~deviceId> as measurement in
		let blob = rep(<measurement,nonce, ~deviceId>,<~skAT,'Trustzone'>) in 
	
		//send attestation report to the app
		[]--[]-> [AndroidIntentFRSW(asid,blob)];
		event S_finish()
		
	)

let App =

	//retrive the developer channel public key for secure coumincation
	[GetDeveloperkey(dvpk)]--[]-> [];
	
	//Create a session key to cominictae with the developer securely
	new ~ask;

	//create an application with its content
	new ~appid;
	new ~appSignature;
	new ~packageName;

	//send application reference publically for potential repacking
	out(~appid);

	//sign this application version with the developer key

	//save the application status
	lock <'app', ~appid>;
    insert <'app', ~appid>, 'valid';
    unlock <'app',~appid>;



	!(
		//lock the application from repaking after this point. advsery need to repack the application before and not during the protocol
		// as repack reqiure re-installing the application
		lock <'app', ~appid>;
        
		//request a nonce from the developer server
		out(aenc(dvpk,<~ask>));

		//retreive a nonoce from the developer server
		in(aenc(~ask,nonce));

		//create a android intent session id, to keep track of the intent session during cominication with attestation agent in the TEE 
		new ~asid;

		//Send nonce to attestation agent and request measuring the device status 
		[]--[]-> [AndroidIntentTOSW(~asid,nonce)];

		//retrive a blob represent the device measurment
		[AndroidIntentFRSW(~asid,blob)]--[]-> [];

		//send the blob to the developer server 
		out(aenc(dvpk,<~ask,blob>));

		//retrive the secret from the developer server as a response from sending blob
		in(aenc(~ask,secret));

		event SecretReceived(secret);

		event A_finish();

		//If the app repacked, export any value (nonce, secret, blob ..etc)
		lookup <'app', ~appid> as status in
		if status = 'invalid' then
			event XA_finish();
			event XD_finish();
			out(secret);
			0
			
		
		//If the app repacked, export any value (nonce, secret, blob ..etc)
		/*
		lookup <'device', deviceId> as measurement in
		if measurement = 'invalid' then
			event XD_finish();
			out(secret);
		
		*/
		//0
	)

//todo : check if blob leaked, what goes wrong

let DevServer =

	//create a developer's pair key for secure cominucaion with clients
	new ~dvk;
	let dbpk = pk(~dvk) in

	//send it public key publically, allows advsery to cominuncate with the developer server
	out(dbpk);

	//send the publick key privatley for  client who request it by URL (authetnication)
	[]--[]-> [GetDeveloperkey(pk(~dvk))];
	
	//create a secret to be sent inexchange for a valid report
	new ~secret;
	event SecretGenerated(~secret);


	!(
		// create a nonce
		new ~nonce;
		// retrive clients' session key
		in(aenc(dbpk,<ask>));
		//send nonce to to clients encrypted with their session key
		out(aenc(ask,~nonce));


		//retrive blob from clients
		in(aenc(dbpk,<ask,blob>));


		//create developer-attesation server session id, to keep track or pair of request-response message  
		new ~sid;
		//send blob to the attestation server
		[]--[]-> [TOAT(~sid,blob)];
		//retreive the verfied report the attestation server, pattern matching is used for checking the status
		[FRAT(~sid,<'valid',~nonce, deviceId>)]--[]-> [];

		//send secret if verdict contain a valid device status
		out(aenc(ask,~secret));

		event D_finish() 
	)
	
let AtServer =
	!(

		//retrive the blob from the developer server and verfiy it
        [TOAT(sid,rep(<measurement,nonce, deviceId>,<~skAT,'Trustzone'>))]--[]-> [];

		//create a verdict  and send it to the developer server
		let verdict = <measurement,nonce, deviceId> in
        []--[]-> [FRAT(sid,verdict)];

		event T_finish() 
	)

// Main process starts here

//create pair attetsation keys to be used by secreworld for sigining, and attestation server for verfication
new ~skAT;
let pkAT = pk(~skAT) in


(!SecureWorld ||!App || !DevServer || AtServer || RepackApp || DeviceTamper)

lemma types [sources]:
	"(All secret #i. SecretReceived(secret) @ i ==> 
	( 
	(Ex #j. KU(secret) @ j & j < i) 
	| (Ex #j. SecretGenerated( secret ) @ j)
	))"

lemma Correctness_D:
exists-trace
	"Ex #i. D_finish()@i"

lemma Correctness_XA:
exists-trace
	"Ex #i. XA_finish()@i"

lemma Correctness_XD:
exists-trace
	"Ex #i. XD_finish()@i"

lemma Correctness_S:
exists-trace
	"Ex #i. S_finish()@i"

lemma Correctness_A:
exists-trace
	"Ex #i. A_finish()@i"

lemma Correctness_T:
exists-trace
	"Ex #i. T_finish()@i"

lemma SecretSecrecy: 
        "(not ( Ex secret #i #k. SecretGenerated(secret) @i & KU(secret) @k ))"

end