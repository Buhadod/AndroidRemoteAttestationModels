/*******************************************************************************
	Knox v2
	AUTHORS
	
	Sample message using SAPIC
	

	Protocol:
	1. C -> S: aenc(k, pkS)
	2. C <- S: h(k)

	Notation:
	
	pmk = Pairwise Master Key
	ptk = Pairwise Transient Key, composed of:
		kck = Key Confirmation Key
		kek = Key Encryption Key
		tk = Temporal Key
	gtk = Group Temporal Key
	
	A_  = Events only in authenticator process
	S_  = Events only in supplicant process
	
*******************************************************************************/

theory CodeProtection
begin

builtins: signing, asymmetric-encryption

functions: create_certificate/3, verify_certificate/2 , get_tbsInfo_certificate/1 , get_ppk_certificate/1

equations:
    create_certificate(SubjectTBSCertificateInfo,SubjectPup,IssuerSk) 
      = < SubjectTBSCertificateInfo, SubjectPup, sign(<SubjectTBSCertificateInfo, SubjectPup>,IssuerSk) >,

    verify_certificate( 
    < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
     , < IssuerTBSCertificateInfo, pk(IssuerSk), sign(<IssuerTBSCertificateInfo, pk(IssuerSk)>,IssuerRootSk) >
          ) = true,

    get_tbsInfo_certificate( 
        < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
          ) = SubjectTBSCertificateInfo,

	get_ppk_certificate( 
        < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
          ) = pk(SubjectSk)
      

let SecureWorld =

	//receive an adversary's attempt to compomised the device
	in(status);

	new ~deviceId;

	//Request attestation server
	[!RequestCreatingIntermediateCertificate(rootSk,rootCertificate)]--[]->[];
	
	//Create keymaster certficate
	new ~keymasterSk;
	let  intermediateCertificate = create_certificate('TbsKeyStoreInfo',pk(~keymasterSk),rootSk) in

	!(
		//recieve nonce from the App
		[AndroidIntentTOSW(asid,nonce,packagename,appSignature)]--[]->[];
		
		new ~key;
		let subjectCertificate = create_certificate(<hardwareMeasurement,nonce,packagename,appSignature>,pk(~key),~keymasterSk) in
		let certificateChain = <subjectCertificate, intermediateCertificate, rootCertificate> in 

		if(status = 'tamper') then
			let hardwareMeasurement = 'invalid' in
			let softwareMeasurement = 'valid' in
			let subjectCertificate = create_certificate(<hardwareMeasurement,nonce,packagename,appSignature>,pk(~key),~keymasterSk) in
			let certificateChain = <subjectCertificate, intermediateCertificate, rootCertificate> in 
			//send attestation report to the app
			[]--[]->[AndroidIntentFRSW(asid,hardwareMeasurement,certificateChain,~deviceId)];
			event S_finish();

			[AndroidIntentTOSW2(asid,aenc(pk(~key), secret))]--[]->[];
			[]--[]->[AndroidIntentFRSW2(asid,secret)];
			0
		else
			let hardwareMeasurement = 'valid' in
			let softwareMeasurement = 'valid' in
			let subjectCertificate = create_certificate(<hardwareMeasurement,nonce,packagename,appSignature>,pk(~key),~keymasterSk) in
			let certificateChain = <subjectCertificate, intermediateCertificate, rootCertificate> in 
			//send attestation report to the app
			[]--[]->[AndroidIntentFRSW(asid,hardwareMeasurement,certificateChain,~deviceId)];
			event S_finish();

			[AndroidIntentTOSW2(asid,aenc(pk(~key), secret))]--[]->[];
			[]--[]->[AndroidIntentFRSW2(asid,secret)];
			0
		
	)

let App =

	//install an application
	in(<packagename,content,sign(key,<packagename,content>)>);

	//retrive the developer channel public key for secure coumincation
	[GetDeveloperkey(dvpk,appSignature, secretSK)]--[]->[];
	
	!(
        
		//Create a session key to cominictae with the developer securely
		new ~ask;

		//request a nonce from the developer server
		out(<'nonce_request'>);

		//retreive a nonoce from the developer server
		in(<'nonce_response',nonce>);

		//create a android intent session id, to keep track of the intent session during cominication with attestation agent in the TEE 
		new ~asid;

		//Send nonce to attestation agent and request measuring the device status 
		[]--[]->[AndroidIntentTOSW(~asid,nonce,packagename,sign(key,<packagename,content>))];

		//retrive a certificateChain represent the device measurment
		[AndroidIntentFRSW(~asid,hardwareMeasurement,certificateChain,deviceId)]--[]->[];

		//send the certificateChain to the developer server 
		out(<'certificateChain_request',certificateChain>);

		//retrive the secret from the developer server as a response from sending certificateChain
		in(<'certificateChain_response',sign(secretSK,secret),payload>);
		
		[]--[]->[AndroidIntentTOSW2(~asid,payload)];

		[AndroidIntentFRSW2(~asid,secret)]--[]->[];

		event SecretReceived(secret);

		event A_finish();
		
		//leak secret if app repacked
		if not(appSignature = sign(key,<packagename,content>)) then
			//out(secret);
			event XA_finish()
		else
			//leak if device tampered 
			if(hardwareMeasurement = 'invalid') then
				//out(secret);
				event XR_finish()
			else
				event AA_finish()
	
	)


//todo : check if blob leaked, what goes wrong

let DevServer =

	//creating and publising the application
	new ~advk;
	new ~content;
	new ~packagename;
	let appSignature = sign(~advk, <~packagename,~content>) in
	let app = <~packagename,~content,appSignature> in
	out(app);

	//create a developer's pair key for secure cominucaion with clients
	new ~dvk;
	let dbpk = pk(~dvk) in

	//send it public key publically, allows advsery to cominuncate with the developer server
	out(dbpk);

	
	
	//create a secret to be sent inexchange for a valid report
	new ~secret;
	new ~secretSK;
	event SecretGenerated(~secret);

	//send the publick key privatley for  client who request it by URL (authetnication)
	[]--[]->[GetDeveloperkey(pk(~dvk),appSignature, ~secretSK)];

	!(
		// create a nonce
		new ~nonce;
		// retrive clients' session key
		in(<'nonce_request'>);
		//send nonce to to clients encrypted with their session key
		out(<'nonce_response',~nonce>);


		//retrive blob from clients
		in(<'certificateChain_request',<subjectCertificate, intermediateCertificate, rootCertificate>>);

		[!GetRootCertificate(rootCertificate)]--[]->[];
		
		let verification1 = verify_certificate(subjectCertificate, intermediateCertificate) in
      	let verification2 = verify_certificate(intermediateCertificate, rootCertificate) in
      	let verification3 = verify_certificate(rootCertificate, rootCertificate) in
		let tbsInfo = get_tbsInfo_certificate(subjectCertificate) in 
		let ppk = get_ppk_certificate(subjectCertificate) in 
		
		new ~vsid;
		[]--[]->[VerficationCertificatehain('verification',<~vsid,verification1,verification2,verification3,<tbsInfo>>)];
		[VerficationCertificatehain('verification',<~vsid,true,true,true,<'valid',~nonce,~packagename,appSignature>>)]--[]->[];
		
		let signature = sign(~secretSK,~secret) in 
		let payload = aenc(ppk, ~secret) in 
		out(<'certificateChain_response',signature,payload>);

		event D_finish() 
	)
	
let AtServer =
	new ~rootSk;
	let rootCertificate = create_certificate('TbsInfo',pk(~rootSk),~rootSk) in

	//share root certficate	
	[]--[]->
	[
		!RequestCreatingIntermediateCertificate(~rootSk,rootCertificate),
		!GetRootCertificate(rootCertificate)
	];

	!(
		event T_finish() 
	)

// Main process starts here

//create pair attetsation keys to be used by secreworld for sigining, and attestation server for verfication
new ~skAT;
let pkAT = pk(~skAT) in


(!SecureWorld ||!App || !DevServer || AtServer)

lemma types [sources]:
	"(All secret #i. SecretReceived(secret) @ i ==> 
	( 
	(Ex #j. KU(secret) @ j & j < i) 
	| (Ex #j. SecretGenerated( secret ) @ j)
	))"

lemma Correctness_D:
exists-trace
	"Ex #i. D_finish()@i"

lemma Correctness_S:
exists-trace
	"Ex #i. S_finish()@i"

lemma Correctness_A:
exists-trace
	"Ex #i. A_finish()@i"

lemma Correctness_XA:
exists-trace
	"Ex #i. XA_finish()@i"

lemma Correctness_XR:
exists-trace
	"Ex #i. XR_finish()@i"

lemma Correctness_AA:
exists-trace
	"Ex #i. AA_finish()@i"

lemma Correctness_T:
exists-trace
	"Ex #i. T_finish()@i"

lemma SecretSecrecy: 
        "(not ( Ex secret #i #k. SecretGenerated(secret) @i & KU(secret) @k ))"

end