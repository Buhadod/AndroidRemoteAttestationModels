/*******************************************************************************
	Knox v2
	AUTHORS
	
	Sample message using SAPIC
	

	Note: The first two messages from the figure are skipped.
	 
	Protocol:
    1. AtServer -> DevServer   	: nonce, apikey
    2. DevServer -> App      	: nonce, apikey
    3. App -> SecureWorld       : nonce
    4. SecureWorld -> App       : blob = aenc(sign (<'NotRooted',nonce, ~deviceId>,~skS), pkT)
    5. App -> DevServer      	: blob, nonce, apikey
    6. DevServer -> AtServer   	: blob, nonce, apikey
    7. AtServer -> DevServer   	: statement
    8. DevServer -> App      	: secret	

	Notation:
	
	skT = Attestation server private key
	pkT = Attestation server public key
	skTLS = Shared key used to send messages through a secure channel (HTTPS, ..etc)
	
	D_ = Developer server prefix 
	A_ = App prefix 
	T_ = Attestation server prefix
	S_ = Secureworld prefix
	

*******************************************************************************/

theory KnoxV2
begin

builtins:
	symmetric-encryption,
	multiset,
	hashing,
	signing,
	asymmetric-encryption


let SecureWorld =
//	new ~S_id;
//	out(~S_id);
	new ~skS;

	let pkS = pk(~skS) in

	insert 'skS', ~skS; 
	new ~deviceId;
	
	!(
		//Step 3: App -> SecureWorld 
		in(senc(~skTLS, <nonce, 'toSW'>));
		let blob = aenc(sign (<'NotRooted',nonce, ~deviceId>,~skS), pkT) in 
	
		//Step 4: SecureWorld -> App 
		out(senc(~skTLS, <blob, 'toApp'>));
		
		event S_finish()
	)

let App =
//	new ~A_id;
//	out(~A_id);

	new ~appSignature;
	new ~packageName;

	//Read from DevServer
	lookup 'apikey' as apikey in 

	!(
		//Step 2: DevServer -> App 
		in(senc(~skTLS,<apikey,nonce,'toApp'>));

		//Step 3: App -> SecureWorld 
		out(senc(~skTLS,<nonce,'toSW'>));

		//Step 4: SecureWorld -> App 
		in(senc(~skTLS,<blob,'toApp'>));

		//Step 5: App -> DevServer
		out(senc(~skTLS, <apikey,nonce,blob,'toDevServer'>)); //Attacker can obtain this msg and do MITM

		//Step 8: DevServer -> App 
		in(senc(~skTLS,<secret,'toApp'>));

		event A_finish()
	)


let DevServer =
//	new ~D_id;
//	out(~D_id);

	new ~apikey;
	insert 'apikey', ~apikey; 

	new ~secret;

	!(
		//Step 1: AtServer -> DevServer 
		in(senc(~skTLS,<~apikey,nonce>));

		//Step 2: DevServer -> App 
		out(senc(~skTLS,<~apikey,nonce,'toApp'>));

		//Step 5: App -> DevServer
		in(senc(~skTLS,<~apikey,nonce,blob,'toDevServer'>));

		//Step 6: DevServer -> AtServer
		out(senc(~skTLS,<~apikey,nonce,blob,'toAtServer'>));

		//Step 7: AtServer -> DevServer 
		in(senc(~skTLS,<~apikey, stmt, 'toDevServer'>));

		//Step 8: DevServer -> App 
		out(senc(~skTLS,<~secret,'toApp'>));

		event D_finish() 
	)
	
let AtServer =
//	new ~T_id;
//	out(~T_id);
	
	!(
		// Read Apikey from DevServer
		lookup 'apikey' as apikey in   

		// Read secureworldkey from  SecureWorld
		lookup 'skS' as skS in  

		new ~nonce;
 
		//Step 1: AtServer -> DevServer 
		out(senc(~skTLS,<apikey,~nonce>));


		//Step 6: DevServer -> AtServer
								/* <-----------------------------blob---------------------->*/
		in(senc(~skTLS, <apikey, ~nonce, aenc(sign (<'NotRooted',~nonce, deviceId>,skS), pkT), 'toAtServer'>));

		let stmt = <'NotRooted',~nonce, deviceId> in

		//Step 7: AtServer -> DevServer 
		out(senc(~skTLS,<apikey, stmt,'toDevServer'>));

		event T_finish() 
	)

// Main process starts here
new ~skT;
let pkT = pk(~skT) in
new ~skTLS;
(!SecureWorld ||!App || !DevServer || AtServer )


lemma Correctness_A:
exists-trace
	"Ex #i. A_finish()@i"

/*
lemma Correctness_D:
exists-trace
	"Ex #i. D_finish()@i"

lemma Correctness_S:
exists-trace
	"Ex #i. S_finish()@i"


lemma Correctness_T:
exists-trace
	"Ex #i. T_finish()@i"

*/
end

/*
==============================================================================
summary of summaries:

analyzed: KnoxV2.sapic

  Correctness_D (exists-trace): verified (9 steps)

==============================================================================
*/