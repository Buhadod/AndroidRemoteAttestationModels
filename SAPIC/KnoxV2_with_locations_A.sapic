theory KnoxV2_locations
begin

builtins:
	symmetric-encryption,
	signing,
	asymmetric-encryption,
    locations-report


let RootedDevice =
                lock <'device', ~id>;
                insert <'device', ~id>, 'rooted';
                event DeviceRooted(~id);
                unlock <'device',~id>;
                0

let RepackedApp =
    !(
        new ~fakeAppPkg;
        new ~fakeAppSignature;

        //install app from store
        in(<appPkg,appSignature>);

        //repacke app with different signature
        event DeveloperAppRepacked(appPkg,~fakeAppSignature);

        //recieve nonce
        in(nonce);

        //send data to secure world once via Android  Intent
        []--[]-> [AndroidIntentENTER(~id,nonce,appPkg,~fakeAppSignature)];

        //receive the blob from secure world  
        [AndroidIntentEXIT(~id,blob,nonce,appPkg,~fakeAppSignature)]--[]-> [];
        
        //send blob to the public channel
        out(<blob,nonce>);

        //Repacked app send blob
        event RepackedAppSendBlob(~id,blob,nonce,appPkg,~fakeAppSignature);

        //App recevied secret
        in(senc(secret,~tlsSessionKey));
        event RepackedAppRecieveSecret(appPkg,secret);
        0
    )

let SecureWorld =
    !(
       
        // calculate measurment
        lock <'device', ~id>;
        lookup <'device', ~id> as measurement in

        //recieve app info in secure world
        [AndroidIntentENTER(~id,nonce,appPkg,appSignature)]--[]-> [];
        
        //generate blob, create attestation report
        let blob = report(<~id, measurement, nonce>) in
        
        //send blob to the app
        event BlobGenerated(~id,blob,nonce,appPkg,appSignature);
        []--[]-> [AndroidIntentEXIT(~id,blob,nonce,appPkg,appSignature)];

        unlock <'device', ~id>;
        0

    )@<'TrustZone', ~id>

let App = 
    !(

        //Install app in device
        in(<appPkg,appSignature>);

        //even app app installed in device 
        event AppInstalled(~id,appPkg,appSignature);

        //recieve nonce
        in(nonce);

        //send data to secure world once via Android  Intent
        []--[]-> [AndroidIntentENTER(~id,nonce,appPkg,appSignature)];

        //receive the blob from secure world  
        [AndroidIntentEXIT(~id,blob,nonce,appPkg,appSignature)]--[]-> [];
        
        //send blob to the public channel
        out(<blob,nonce>);

        //App send blob
        event AppSendBlob(~id,blob,nonce,appPkg,appSignature);

         //App recvied secret
        in(senc(secret,~tlsSessionKey));
        event AppRecieveSecret(~id,appPkg,appSignature,secret);
        0
    )




let YourServer =
    !(
        //new ~tlsSessionKey;
        //insert 'tlsSessionKey', ~tlsSessionKey;
        new ~appPkg;
        new ~appSignature;

        new ~secret;
        out(<~appPkg,~appSignature>);
        event DeveloperApp(~appPkg,~appSignature,~secret);
        
        
        out(senc(~id, ~tlsSessionKey));
        in(senc(nonce, ~tlsSessionKey));
        out(nonce);
        //receive report from TrustZone
        //send report from TrustZone to attServer.
        in(senc(veredict, ~tlsSessionKey));
        if veredict = <~id, 'veredictOK'> then
            event VeredictOK(~id);
            event DeveloperSendSecret(~appPkg,~secret);
            out(senc(~secret,~tlsSessionKey));
            0
            
        else
            event VeredictNoOK(~id);
            0
    )

let AttestServer =
    !(
        //lookup 'tlsSessionKey' as tlsSessionKey in
        in(senc(~id, ~tlsSessionKey));        
        new ~nonce;
        out(senc(~nonce, ~tlsSessionKey));
        in(<blob,~nonce>);
                                        //orginal msg = msg , signature
        if <~id, 'nonRooted', ~nonce> = check_rep(blob, <'TrustZone', ~id>) then
            out(senc(<~id, 'veredictOK'>, ~tlsSessionKey));
            0
            
        else
            out(senc(<~id, 'veredictNotOK'>, ~tlsSessionKey));
            0    
           
    )


new ~tlsSessionKey;
//out(~tlsSessionKey);
new ~ssk_AttestServer;
let spk_AttestServer = pk(~ssk_AttestServer) in
out(spk_AttestServer);
insert 'device', 'nonRooted';    
new ~id;
(SecureWorld| RootedDevice| App | YourServer | AttestServer  | RepackedApp)


// Device recieve secret
lemma Correctness:
exists-trace
	"Ex id appPkg appSignature secret #i. AppRecieveSecret(id,appPkg,appSignature,secret)@i"

lemma CorrectnessDev:
exists-trace
	"Ex appPkg  secret #i. DeveloperSendSecret(appPkg,secret)@i"

/*
lemma secretLeakedIfEntitiesComprimsed:
  " All id blob nonce appPkg appSignature fakeappSignature secret #a #b #c #d #k.
      DeveloperApp(appPkg,appSignature,secret) @a 
      & AppInstalled(id,appPkg,fakeappSignature) @b // or fakeAppPKG
      & AppSendBlob(id,blob,nonce,appPkg,fakeappSignature) @c
      & AppRecieveSecret(id,appPkg,fakeappSignature,secret) @d
        ==> 
          (  not(appSignature =  fakeappSignature))
  "
*/

// (conclusion) => (fisrt)
//it is not possibile for a repacked app to obtain a secret sent via developer
lemma secretLeacked:
    "( not( Ex appPkg secret #i #j. RepackedAppRecieveSecret(appPkg,secret)@i & DeveloperSendSecret(appPkg,secret)@j ))"
end


