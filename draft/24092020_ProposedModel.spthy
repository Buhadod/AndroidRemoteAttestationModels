theory AbdullaProtocol
begin

builtins: asymmetric-encryption, signing

/* We formalize the following protocol

 
    1. Server -> App    : N_s
    2. App -> SecWorld  : N_s
    3. SecWorld -> App  : Sign_Sk(N_s,Pk_S) 
    4. App -> Server    : Sign_Sk(N_s,Pk_S)
    5. Server -> DevSvr : Sign_Sk(N_s,Pk_S)
    6. DevSvr -> Server : Sign_Dk(N_s,Pk_S)
    7. Server -> App    : E_PkS(code)
    8. App -> SecWorld  : E_PkS(code)
    9. SecWorld -> App  : code
*/

/*
Assumiption that IMEI is secure (not really in secure world)?

App(codeHash,deviceID, devVerifyKey),  

SecWorldInfoNotRooted(deviceID,IMEI,venderPubKey,SW_signingKey),
SecWorldInfoRooted(deviceID,IMEI,venderPubKey,SW_signingKey),

We assume only one app per developer, for now
DevServerKey(ltkD,pk(ltkD))

VenderServerKeys(venderPrivKey, pk(venderPrivKey), venderSignKey, pk(venderSignKey))

VenderServerInfo(venderPrivKey, venderSignKey, SW_ver_key, IMEI)  <== what if vender has two devs on same device??
VenderServerKnownDevKey(venderPubKey,devPubKey)

NotRooted App  
NotRooted Stopped -> Rooted 
Rooted App 

*/

/* Set up rules */
rule CreateVender:
  [ 
    Fr(~venderPrivKey),
    Fr(~venderSignKey)
  ]
  --[ ]->
  [
    !VenderServerKeys(~venderPrivKey, pk(~venderPrivKey), ~venderSignKey, pk(~venderSignKey))
  ]

rule VenderComprimse:
  [ 
    !VenderServerKeys(venderPrivKey, venderPubKey, venderSignKey, pk(venderSignKey))
  ]
  --[ VenderComprimsed(venderPubKey) ]->
  [
    Out(<venderPrivKey, venderSignKey>)
  ]

rule DevComprimse:
  [ 
    !DevServerKey(devPrivKey, devPubKey, devSignKey, pk(devSignKey))
  ]
  --[ DevComprimsed(devPubKey) ]->
  [
    Out(<devPrivKey, devSignKey>)
  ]

rule SecWorldComprimse:
  [ 
    !SecWorldInfoNotRooted(deviceID,IMEI,venderPubKey,secWorldSignKey)
  ]
  --[ SecWorldComprimsed(IMEI) ]->
  [
    Out(<IMEI>)
  ]


rule CreateDevice:
  [ 
    Fr(~deviceID), Fr(~IMEI), Fr(~secWorldSignKey),
    !VenderServerKeys(venderPrivKey, venderPubKey, venderSignKey, venderVerifyKey)
  ]
  --[ ]->
  [
    !SecWorldInfoNotRooted(~deviceID,~IMEI,venderPubKey,~secWorldSignKey),
    !VenderServerInfo(venderPrivKey, venderSignKey, pk(~secWorldSignKey), ~IMEI) 
  ]

rule CreateUntrustedDevice:
  [ 
    Fr(~deviceID), Fr(~IMEI), Fr(~secWorldSignKey),
    Fr(~venderPrivKey),Fr(~venderPubKey),Fr(~venderSignKey),Fr(~venderVerifyKey)
  ]
  --[ ]->
  [
    !SecWorldInfoRooted(~deviceID,~IMEI,~venderPubKey,~secWorldSignKey)
  ]


  rule CreateDeveloper:
  [ 
    Fr(~devPrivKey), Fr(~devSignKey)
  ]
  --[ Developer(~devPrivKey, pk(~devPrivKey), ~devSignKey, pk(~devSignKey)) ]->
  [
    !DevServerKey(~devPrivKey, pk(~devPrivKey), ~devSignKey, pk(~devSignKey))
  ]

  rule CreateApp:
  [
    Fr(~codeHash), Fr (~secret),
    !DevServerKey(devPrivKey,devPupKey,devSignKey,devVerifyKey),
    !VenderServerKeys(venderPrivKey, venderPubKey, venderSignKey, venderVerifyKey)
  ]
  --[ DevCreateApp(~codeHash, ~secret,devPupKey,devVerifyKey,devSignKey, venderPubKey, venderVerifyKey)
  
  ]->
  [
    !DevApp(~codeHash, ~secret,devPupKey,devVerifyKey,devSignKey, venderPubKey, venderVerifyKey)
  ]


  rule InstallAppDevice:
  [
      !DevApp(codeHash, secret,devPupKey,devVerifyKey,devSignKey, venderPubKey, venderVerifyKey),
      !SecWorldInfoNotRooted(deviceID,IMEI,venderPubKey,secWorldSignKey)
  ]
  --[ 
      InstallAppInDevice(codeHash,secret,IMEI,deviceID,devPupKey)
   ]->
  [
      !App(codeHash, deviceID,devVerifyKey)
  ]
  
  
  rule InstallAppUntrustedDevice:
  [
      !DevApp(codeHash, secret,devPupKey,devVerifyKey,devSignKey, venderPubKey, venderVerifyKey),
      !SecWorldInfoRooted(deviceID,IMEI,venderPubKey,secWorldSignKey)
  ]
  --[ 
      InstallAppInDevice(codeHash,secret,IMEI,deviceID,devPupKey)
   ]->
  [
      !App(codeHash, deviceID,devVerifyKey)
  ]

/* Protocol rules*/
rule DS_to_App_1:
    [
      Fr(~nd)
    ]
  --[ 
       DevStart(~nd)
    ]->
    [ 
      Out( ~nd ),
      DS_State(~nd)
    ]

rule DS_App_SecW_2:
    [
      In(nd), 
      !App(codeHash, deviceID, devVerifyKey)
    ]
  --[ 
      RequestAttestation(nd,codeHash,deviceID)
    ]->
    [ 
      SecWorld_RequestAtt(nd,codeHash,deviceID)
    ]


rule App_SecW_App_3:
  
  let blob  = aenc(sign (<IMEI, 'NotRooted',nd, codeHash, pk(~sessionPrivKey)>,SW_signingKey), venderPubKey)

  in
    [
       Fr(~sessionPrivKey),
       !SecWorldInfoNotRooted(deviceID,IMEI,venderPubKey,SW_signingKey),
       SecWorld_RequestAtt(nd,codeHash,deviceID)
    ]
  --[ 
      Attestation(nd,codeHash,deviceID)
    ]->
    [ 
      !SecWorldSessionKey(deviceID,~sessionPrivKey),
      SecWorld_Attestation(blob)
    ]


rule SecW_App_DS_4:
    [
      SecWorld_Attestation(blob)
    ]
  --[ AppSend(blob) ]->
    [ 
      Out( blob )
    ]

/* skipping App_DS_VS because its a basic forward */

rule DS_VS_DS_5:
  let 
    blob  = aenc(sign (<IMEI, 'NotRooted',nd, codeHash,sessionPubKey>,SecWorldSignKey), pk(venderPrivKey))
    sigma = sign(<IMEI, 'NotRooted',nd, codeHash,sessionPubKey>, venderSignKey)
  in
    [
      !VenderServerInfo(venderPrivKey, venderSignKey, pk(SecWorldSignKey), IMEI),
      /*!VenderServerKnownDevKey(venderPubKey,devPubKey),*/
      In (blob)
    ]
    --[ VenderChecked(IMEI, nd, codeHash, sessionPubKey, blob) ]->
    [ 
      Out(<IMEI, 'NotRooted',nd, codeHash,sessionPubKey,sigma>) 
    ]

rule VS_DS_App_6:
  let 
    sigma = sign(<IMEI, 'NotRooted',nd, codeHash,sessionPubKey>, venderSignKey)
  in
    [
      DS_State(nd),
      !DevServerKey(devPrivKey,devPubKey,devSignKey,devVerifyKey),
      !DevApp(codeHash, secret,devPupKey,devVerifyKey,devSignKey, venderPubKey, pk(venderSignKey)),
      In(<IMEI, 'NotRooted',nd, codeHash,sessionPubKey,sigma>)
    ]
    --[ DevSerSendSec(secret,nd,IMEI,codeHash) ]->
    [ 
      Out( sign( aenc( <secret,codeHash>,sessionPubKey ), devSignKey ) )
    ]


rule DS_App_SecWorld_7:
    let signEncSec = sign(encSec, devSignKey) in
    [
      In(signEncSec),
      !App(codeHash,deviceID, pk(devSignKey) )
    ]
    --[ AppAcceptEncSec(encSec, codeHash, deviceID) ]->
    [
      SecWorldDecReq(encSec,codeHash,deviceID)
    ]

rule App_SecWorld_App_8:
    [
       SecWorldDecReq(aenc(<secret,codeHash>, pk(sessionPrivKey)), codeHash,deviceID),
       !SecWorldInfoNotRooted(deviceID,IMEI,SW_cert,SW_signingKey),
       !SecWorldSessionKey(deviceID,sessionPrivKey)
    ]
    --[ SecWorldSentCode(deviceID,codeHash,secret) ]->
    [
      
    ]


lemma types [sources]:
" All IMEI nd codeHash sessionPubKey blob #i.
    VenderChecked(IMEI, nd, codeHash, sessionPubKey, blob) @i
    ==>   ( Ex #j. AppSend(blob) @ j & #j < #i) 
        | ( Ex #k. KU(<IMEI, nd, codeHash, sessionPubKey>) @ k & #k < #i)"

lemma testTrace:
  exists-trace 
  " Ex #i deviceID codeHash secret.
      SecWorldSentCode(deviceID,codeHash,secret) @ i "

lemma onlyTrustedAppsCanGetSecret:
  " All deviceID codeHash secret devPupKey #i #d.
      SecWorldSentCode(deviceID,codeHash,secret) @ #i
      & (not(DevComprimsed(devPupKey) @ #d))
        ==> (Ex #j IMEI. InstallAppInDevice(codeHash,secret,IMEI,deviceID,devPupKey) @ #j & #j < #i )"

lemma secretLeakedIfEntitiesComprimsed:
  " All codeHash secret devPupKey devVerifyKey devSignKey venderPubKey venderVerifyKey IMEI deviceID #i #j #k.
      DevCreateApp(codeHash, secret,devPupKey, devVerifyKey, devSignKey, venderPubKey, venderVerifyKey) @ #i
      & InstallAppInDevice(codeHash,secret,IMEI,deviceID,devPupKey) @ #j
      & KU(secret) @ #k
        ==> 
          ( Ex #a. VenderComprimsed(venderPubKey) @ #a & #i < #j & #i < #a & #a < #k) 
        | ( Ex #b. DevComprimsed(devPupKey) @ #b       & #i < #j & #i < #b & #b < #k) 
        | ( Ex #c. SecWorldComprimsed(IMEI) @ #c       & #i < #j & #j < #c & #c < #k) 
  "
end