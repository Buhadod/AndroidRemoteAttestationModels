theory KnoxV2
begin

builtins: asymmetric-encryption, signing

/* We formalize the following protocol

    1. Vender -> Developer   : N_v
    2. Developer -> App      : N_v
    3. App -> SecWorld       : N_v
    4. SecWorld -> App       : Stmt = <N_s, measurement, deviceID>, E_venderPubKey(Sign_secWorldSignKey(Stmt),Stmt) i.e (blob)
    5. App -> Developer      : blob, N_s, apikey
    6. Developer -> Vender   : blob, N_s
    7. Vender -> Developer   : stmt
    8. Developer -> App      : secret
*/

/*
  Assumiption:
  

*/

/* Set up rules */
rule CreateVender:
  [ 
    Fr(~venderPrivKey),Fr(~apiKey)
  ]
  --[ ]->
  [
    !VenderKeys(~venderPrivKey, pk(~venderPrivKey)),
    !VenderInfo(~apiKey)
  ]

rule VenderComprimse:
  [ 
    !VenderKeys(venderPrivKey, venderPubKey)
  ]
  --[ VenderComprimsed(venderPubKey) ]->
  [
    Out(<venderPrivKey, venderPubKey>)
  ]

rule CreateDevice:
  [ 
    Fr(~deviceID), Fr(~secWorldSignKey),
    !VenderKeys(venderPrivKey, venderPubKey)
  ]
  --[ ]->
  [
    !SecureWorldInfo(~deviceID,venderPubKey,~secWorldSignKey),
    !VenderDevicesInfo(venderPrivKey, venderSignKey, ~secWorldSignKey, ~deviceID) 
  ]

rule SecWorldComprimse:
  [ 
    !SecureWorldInfo(deviceID,venderPubKey,~secWorldSignKey)
  ]
  --[ SecWorldComprimsed(deviceID) ]->
  [
    Out(<deviceID>)
  ]

  rule CreateDeveloper:
  [ 
    Fr(~secret),
    !VenderInfo(apiKey)
  ]
  --[ ]->
  [
    !DeveloperSecret(~secret),
    !DeveloperInfo(apiKey)
  ]

rule DevComprimse:
  [ 
    !DeveloperInfo(secret)
  ]
  --[ DevComprimsed(secret) ]->
  [
    Out(<secret>)
  ]


  rule CreateApp:
  [
    Fr(~appSHA),
    !DeveloperInfo(apiKey)
  ]
  --[ ]->
  [
    !AppInfo(~appSHA, apiKey)
  ]



/* Protocol rules*/
rule Ven_to_Dev_1:
    [
      Fr(~nv),
      !VenderInfo(apiKey)
    ]
  --[ 
       St_Vendor_to_Developer(~nv, apiKey)
    ]->
    [ 
      Out( <~nv, apiKey> ),
      !Vendor_to_Developer(~nv)
    ]

rule Dev_to_App_2:
    [
      In(<nv, apiKey>),
      !DeveloperInfo(apiKey)
    ]
  --[ 
      St_Developer_to_App(nv, apiKey)
    ]->
    [ 
      Out( <nv,apiKey> ),
      !Developer_to_App(nv,apiKey)
    ]

rule App_to_SecWorld_3:
    [
      In(<nv,apiKey>),
      !AppInfo(appSHA, apiKey)
    ]
  --[ 
      St_App_to_SecWorld(nv)
    ]->
    [ 
      !App_to_SecWorld(nv),
      !AppInfo_2(nv, appSHA, apiKey)
    ]

rule SecWorld_to_App_4:
    
    let blob = aenc(sign (<'NotRooted',nv, deviceID>,secWorldSignKey), venderPubKey)

    in
    [
      !App_to_SecWorld(nv),
      !SecureWorldInfo(deviceID,venderPubKey,secWorldSignKey)
    ]
  --[ 
      St_SecWorld_to_App(blob)
    ]->
    [ 
      !SecWorld_to_App(blob)
    ]

rule App_to_Dev_5:
    [
      In(blob),
      !AppInfo_2(nv, appSHA, apiKey)
    ]
  --[ 
      St_App_to_Dev(nv, blob, appSHA,apiKey)
    ]->
    [ 
      Out(<blob, nv, apiKey>),
      App_to_Dev(blob, nv, apiKey)
    ]

rule Dev_to_Ven_6:
    [
      In(<blob, nv, apiKey>),
      !Developer_to_App(nv,apiKey)
    ]
  --[ 
      St_App_to_Dev(nv, blob,apiKey)
    ]->
    [ 
      Out(<blob, nv, apiKey>),
      Dev_to_Ven(blob, nv, apiKey)
    ]

rule Ven_to_Dev_7:
    
    let blob = aenc(sign (<'NotRooted',nv, deviceID>,secWorldSignKey), venderPubKey)

    in
    [
      In(<blob, nv, apiKey>),
      !Vendor_to_Developer(~nv),
      !VenderKeys(venderPrivKey, venderPubKey),
      !VenderDevicesInfo(venderPrivKey, venderSignKey, secWorldSignKey, deviceID) 
    ]
  --[ 
      St_Ven_to_Dev('NotRooted',blob, nv, deviceID)
    ]->
    [ 
      Out(<'NotRooted',nv, deviceID, apiKey>)
    ]

rule Dev_to_App_8:
    [
      In(<'NotRooted',nv, deviceID, apiKey>),
      !Developer_to_App(nv,apiKey),
      !DeveloperSecret(secret),
      !DeveloperInfo(apiKey)
    ]
  --[ 
      St_Dev_to_App(nv, blob, apiKey, secret)
    ]->
    [ 
      Out(<secret,apiKey>)
    ]


lemma types [sources]:
" All IMEI nd codeHash sessionPubKey blob #i.
    VenderChecked(IMEI, nd, codeHash, sessionPubKey, blob) @i
    ==>   ( Ex #j. AppSend(blob) @ j & #j < #i) 
        | ( Ex #k. KU(<IMEI, nd, codeHash, sessionPubKey>) @ k & #k < #i)"

lemma testTrace:
  exists-trace 
  " Ex #i deviceID codeHash secret.
      SecWorldSentCode(deviceID,codeHash,secret) @ i "

lemma onlyTrustedAppsCanGetSecret:
  " All deviceID codeHash secret #i #j devPupKey.
      DevSerSendSecret(devPupKey,codeHash,secret) @ #i
      & SecWorldSentCode(deviceID,codeHash,secret) @ #j
      & not(Ex #k devPupKeyLocal. DevComprimsed(devPupKeyLocal) @#k & devPupKeyLocal=devPupKey)
        ==> (Ex #l IMEI. InstallAppInDevice(codeHash,secret,IMEI,deviceID,devPupKey) @ #l & #l < #j)"

lemma secretLeakedIfEntitiesComprimsed:
  " All codeHash secret devPupKey devVerifyKey devSignKey venderPubKey venderVerifyKey IMEI deviceID #i #j #k.
      DevCreateApp(codeHash, secret,devPupKey, devVerifyKey, devSignKey, venderPubKey, venderVerifyKey) @ #i
      & InstallAppInDevice(codeHash,secret,IMEI,deviceID,devPupKey) @ #j
      & KU(secret) @ #k
        ==> 
          ( Ex #a. VenderComprimsed(venderPubKey) @ #a & #i < #j & #i < #a & #a < #k) 
        | ( Ex #b. DevComprimsed(devPupKey) @ #b       & #i < #j & #i < #b & #b < #k) 
        | ( Ex #c. SecWorldComprimsed(IMEI) @ #c       & #i < #j & #j < #c & #c < #k) 
  "
end