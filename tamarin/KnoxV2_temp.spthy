theory KnoxV2
begin

builtins: signing

functions: check_rep/2,  get_rep/1, rep/2 [private]

equations:
    check_rep(rep(x.1, x.2), x.2) = true,
    get_rep(rep(x.1, x.2)) = x.1


/*
 * Protocol:     KnoxV2
 * Modeler:      Code protection project
 * Described in: https://developer.android.com/training/safetynet/attestation
 * Figure        Based on figures/a.pdf
 * Date:         July 2021
 *
 * Status:       working
 */

/* We formalize the following protocol


*/



rule CreateDeveloper:
  [
    Fr(~developerSk),
    Fr(~d_id)
  ]
  --[ DeveloperCreated(~d_id,~developerSk)]->
  [
    !GetDeveloperKey(~d_id,~developerSk)
  ]

rule CreateApplication:
  let 
      //appContent is an abstraction for application sourcecode and resources
      appPackage = <~appPackageName,~appContent>
      appSignature = sign(appPackage,developerSk)
  in
  [
    Fr(~appContent),
    Fr(~appPackageName),
    !GetDeveloperKey(d_id,developerSk)
  ]
  --[ CreateApp(~appPackageName,~appContent,d_id)]->
  [
    !App(appPackage,appSignature),
    !DeveloperApp(d_id,appPackage,appSignature)
  ]

rule RepackProcess:
  let 
    repackedAppPackage = <appPackageName,~repackedContent>
    selfsignAppSignature = sign(repackedAppPackage,debugSk)
  in  
  [ 
    !App(<appPackageName,appContent>,appSignature),
    Fr(~repackedContent),
    In(debugSk)
  ]
  --[ RepackApp(appPackageName,appContent,~repackedContent)]->
  [
    !App(repackedAppPackage,selfsignAppSignature)
  ]

rule CreateDevice:
  let 
  software_measurement = 'valid' 
  hardware_measurement = 'valid' in
  [ 
    Fr(~attestationKey)
  ]
  --[ KeyGenerated(~attestationKey)]->
  [
    !Device(~attestationKey,software_measurement,hardware_measurement),
    !Server_SecureWorld(~attestationKey)
  ]


rule UnlockBootloaderProcess:
  let 
    updated_hardware_measurement = 'invalid' in
  [ 
    In(<fake_measurement>),
    !Device(attestationKey,software_measurement,hardware_measurement)
  ]
  --[ BootloaderUnlocked(attestationKey)]->
  [
    !Device(attestationKey,fake_measurement,updated_hardware_measurement)
  ]

/* Protocol rules*/

rule Dvr_to_App_1:
    [
      !GetDeveloperKey(d_id,developerSk),
      Fr(~nonce)
    ]
  --[NonceGenerated(~nonce,d_id)]->
    [ 
      PrivateChannelA('HTTPS_DeveloperServer_APP', ~nonce),
      DeveloperCreateNonce(~nonce,d_id)
    ]

rule App_to_SecW_2:
    [
      !App(appPackage,appSignature),
      //create attestation session id (sid)
      Fr(~sid),
      Fr(~app_id),
      PrivateChannelA('HTTPS_DeveloperServer_APP', nonceA )
    ]
  --[ AppReceieveNonce(~app_id, appPackage,nonceA) ]->
    [ 
      PrivateChannelB('secureChannel',<~sid,nonceA,appPackage,appSignature,~app_id>),
      SaveAppStatus(~sid,~app_id,appPackage,appSignature)
    ]

rule SecW_to_App3:
    let 
       blob = rep(<nonceSW,software_measurement,hardware_measurement>,<attestationKey,'Trustzone'>) 
    in
    [
      PrivateChannelB('secureChannel', <sid,nonceSW,appPackage,appSignature,app_id> ),
      !Device(attestationKey,software_measurement,hardware_measurement),
      Fr(~dev_id)
      
    ]
  --[BlobGenerated(blob,app_id,~dev_id)  ]->
    [ 
      PrivateChannelC('secureChannel', <sid,blob>),
      SaveDeviceStatus(sid,app_id,~dev_id,appPackage,appSignature,software_measurement,hardware_measurement)
    ]

rule App_to_Dvr4:
    [
      PrivateChannelC('secureChannel',<sid,blob>),
      //Get app integrity check
      SaveAppStatus(sid,app_id,appPackage,appSignature)
    ]
  --[]->
    [ 
      PrivateChannelD('HTTPS_DeveloperServer_APP',<sid,blob>),
      
      LeakBlobIfAppRepacked(sid,app_id,appPackage,appSignature,blob)
    ]

rule App_to_Dvr4_Leakage:
  [
    //retrive debug key
    In(debugSk),
    //check if the app selfsigned/repacked
    LeakBlobIfAppRepacked(sid,app_id,<appPackageName,appContent>,sign(<appPackageName,appContent>,debugSk),blob)
  ]
  --[BlobLeaked(blob,app_id)]->
  [
    //create partial deconstruction and no needed
    //Out(blob)
  ]

rule Dvr_to_Svr_5:
  [
    PrivateChannelD('HTTPS_DeveloperServer_APP',<sid,blob>)
  ]
  --[]->
  [
    PrivateChannelE('HTTPS_DeveloperServer_AttestationServer',<sid,blob>)
  ]


rule Svr_to_Dvr_6:
    [
      PrivateChannelE('HTTPS_DeveloperServer_AttestationServer',<sid,rep(<nonceSW,software_measurement,hardware_measurement>,<attestationKey,'Trustzone'>)> ),
      !Server_SecureWorld(attestationKey)
    ]
  --[Debug()]->
    [ 
      PrivateChannelF('HTTPS_DeveloperServer_AttestationServer',<sid,nonceSW,software_measurement,hardware_measurement>)
    ]

rule Dvr_to_App_7:
    [
      PrivateChannelF('HTTPS_DeveloperServer_AttestationServer',<sid,nonceSW,'valid','valid'> ),
      DeveloperCreateNonce(nonceSW,d_id),
      Fr(~secret)
    ]
  --[ NonceReceived(nonceSW), SecretGenerated(~secret), Debug2()]->
    [ 
      PrivateChannelG('HTTPS_DeveloperServer_APP',<sid,~secret, nonceSW>)
    ]

rule App_from_Dvr_8:
    [
      PrivateChannelG('HTTPS_DeveloperServer_APP',<sid,secret, nonceSW>),
      //Get Device integrity from attestation time
      SaveDeviceStatus(sid,app_id,dev_id,appPackage,appSignature,software_measurement,hardware_measurement)
    ]
  --[ SecretReceived(secret), SecretReceivedAtApp(secret,app_id), SecretReceivedAtDevice(secret,dev_id)]->
    [
      LeakSecretIfAppRepacked(app_id, appPackage,appSignature,secret),
      LeakSecretIfDeviceCompomised(dev_id,hardware_measurement,secret)
    ]

rule App_from_Svr8_If_Leakage_via_app_repack:
    [
      //retrive debug key
      In(debugSk),
      //check if the app selfsigned
      LeakSecretIfAppRepacked(app_id,<appPackageName,appContent>,sign(<appPackageName,appContent>,debugSk),secret)
    ]
  --[ SecretLeaked(secret), AppRepacked(app_id)]->
    [
      Out(secret)
    ]

rule App_from_Svr8_If_Leakage_via_device_compomised:
    [
      LeakSecretIfDeviceCompomised(dev_id,'invalid',secret)
    ]
  --[ SecretLeaked(secret), DeviceTampered(dev_id)]->
    [
      Out(secret)
    ]

lemma Debug: exists-trace "Ex #i . Debug2()@i" 

//Reachability : Protocal can finish
/*
lemma Prove1: 
  exists-trace 
  "Ex app_id appPackageName appContent nonce d_id #i #j #k.
      CreateApp(appPackageName,appContent,d_id) @i
      & AppReceieveNonce(app_id,<appPackageName,appContent>, nonce) @j
      & NonceReceived(nonce) @k
  "
*/



//Reachiability
lemma ProtocolFinished:
exists-trace
        "Ex secret #i. SecretReceived(secret)@i"

//Secret Secrecy : It is not possibile for a secret to be leacked by adevsery
lemma SecretSecrecy: 
        "(not ( Ex secret #i #k. SecretGenerated(secret) @i & KU(secret) @k ))"

//Application Integrity : It is not possibile for a secret to be recived by a repacked application
lemma ApplicationIntegrity: 
        "(not (Ex secret app_id #i #k. SecretReceivedAtApp(secret,app_id)@i & AppRepacked(app_id)@k ))"

//Device Integrity : It is not possible for a secret to be recieved by a compromised device
lemma DeviceIntegrity: 
        "(not (Ex secret dev_id #i #k. SecretReceivedAtDevice(secret,dev_id)@i & DeviceTampered(dev_id)@k ))"

//Nonce freshness: For all same nonce generated by developer 1 and developer 2 => they are the same nonce
lemma NonceFreshness:
        "All d_id1 d_id2 nonce #t1 #t2. NonceGenerated(nonce,d_id1)@t1 & NonceGenerated(nonce,d_id2)@t2 ==> (d_id1 = d_id2)"
end
