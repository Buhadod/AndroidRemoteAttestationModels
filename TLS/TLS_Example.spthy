/*
Initial Example for the Tamarin Manual
======================================

Authors:    Simon Meier, Benedikt Schmidt
Updated by:     Jannik Dreier, Ralf Sasse
Date:           June 2016

This file is documented in the Tamarin user manual.

*/

theory TLS_Example
begin

builtins: hashing, asymmetric-encryption, symmetric-encryption

// Public key infrastructure 
// Registering a public key
rule Register_pk:
    [ Fr(~ltk) ] --> [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]

rule Get_pk:
    [ !Pk(A, pubkey) ] --> [ Out(pubkey) ]

// Compromising an agent's long-term key 
rule Reveal_ltk:
    [ !Ltk(A, ltk) ] --[ LtkReveal(A) ]->[ Out(ltk) ]




// Start a new thread executing the client role, choosing the server // non-deterministically.
rule Client_1:
    [ Fr(~k) , !Pk($S, pkS) ]        // choose fresh key // lookup public-key of server
  -->
    [ Client_1( $S, ~k ) , Out( aenc(~k, pkS) )]    // Store server and key for next step of thread // Send the encrypted session key to the server

// A server thread answering in one-step to a session-key setup request from // some client.
rule Serv_1:
    let
      request = aenc(k, pk(~ltkS))
    in
    [ !Ltk($S, ~ltkS)  , In( request ) ]      // lookup the private-key // receive a request
  --[ AnswerRequest($S, k) ]->                // Explanation below
    [ Server_1($S, k) ]                       // Save the session key for later action

// A server send some secret to the client using its session key
rule Serv_2:
  [ !Ltk($S, ~ltkS), Fr(~secret),  Server_1($S, k)]     //Retrive the session key for the client
  --[ Trace1(~secret, k, $S)]->
  [ Out( senc(~secret,k) ) ]                            //Encrypt some response data with the client session key

// A client recieve some encrypted response
rule Client_2:
    let 
      response = senc(secret,k)
    in
    [ Client_1(S, k) , In( response ) ]  // Retrieve server and session key from previous step  // Receive hashed session key from network  
  --[ SessKeyC( S, k ), Trace2(secret, k, S) ]-> // State that the session key 'k' // was setup with server 'S'
    []  


lemma execution:
 " /* It cannot be that a  */
    not(
      Ex S k secret #i #j #m.
        /* client has set up a session key 'k' with a server'S' */
        Trace2(secret, k, S) @ #i
        & Trace1(secret, k, S) @ #m
        & m < i
        /* and the adversary knows 'k' */
      & K(k) @ #j
        /* without having performed a long-term key reveal on 'S'. */
      & not(Ex #r. LtkReveal(S) @ r)
    )
  "

lemma Client_session_key_secrecy:
  " /* It cannot be that a  */
    not(
      Ex S k #i #j.
        /* client has set up a session key 'k' with a server'S' */
        SessKeyC(S, k) @ #i
        /* and the adversary knows 'k' */
      & K(k) @ #j
        /* without having performed a long-term key reveal on 'S'. */
      & not(Ex #r. LtkReveal(S) @ r)
    )
  "

lemma Client_auth:
  " /* For all session keys 'k' setup by clients with a server 'S' */
    ( All S k #i.  SessKeyC(S, k) @ #i
       ==>
         /* there is a server that answered the request */
       ( (Ex #a. AnswerRequest(S, k) @ a)
         /* or the adversary performed a long-term key reveal on 'S'
            before the key was setup. */
       | (Ex #r. LtkReveal(S) @ r & r < i)
       )
    )
  "

lemma Client_auth_injective:
  " /* For all session keys 'k' setup by clients with a server 'S' */
    ( All S k #i.  SessKeyC(S, k) @ #i
       ==>
         /* there is a server that answered the request */
       ( (Ex #a. AnswerRequest(S, k) @ a
           /* and there is no other client that had the same request */
           & (All #j. SessKeyC(S, k) @ #j ==> #i = #j)
       )
         /* or the adversary performed a long-term key reveal on 'S'
            before the key was setup. */
       | (Ex #r. LtkReveal(S) @ r & r < i)
       )
    )
  "

lemma Client_session_key_honest_setup:
  exists-trace
  " Ex S k #i.
        SessKeyC(S, k) @ #i
      & not(Ex #r. LtkReveal(S) @ r)
  "

end