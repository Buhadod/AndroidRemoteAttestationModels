/*******************************************************************************
	Remote attestation Framework
	AUTHORS
	
	
*******************************************************************************/

theory Framework_KeyAttestation_App_CP_Clean_1
begin

builtins: signing, asymmetric-encryption

functions: check_rep/2,  get_rep/1, rep/2 [private], create_certificate/3, verify_certificate/2 , get_tbsInfo_certificate/1, get_public_key_certificate/1

equations:
    check_rep(rep(x.1, x.2), x.2) = true,
    get_rep(rep(x.1, x.2)) = x.1,

    create_certificate(SubjectTBSCertificateInfo,SubjectPup,IssuerSk) 
      = < SubjectTBSCertificateInfo, SubjectPup, sign(<SubjectTBSCertificateInfo, SubjectPup>,IssuerSk) >,

    verify_certificate( 
    < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
     , < IssuerTBSCertificateInfo, pk(IssuerSk), sign(<IssuerTBSCertificateInfo, pk(IssuerSk)>,IssuerRootSk) >
          ) = true,

    get_tbsInfo_certificate( 
        < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
          ) = SubjectTBSCertificateInfo,

	get_public_key_certificate( 
	< SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
		) = pk(SubjectSk)
      


/***************************************** Generic *****************************************/

let Np = 

	in(cipher);
	event CipherReceived(cipher);
	0


let KeyApp = 
    [Nonce_Sent(devId,nonce)]--[]-> [];

	event NonceRecieved(nonce);
	new ~iid;
	//attestation_agent send app data to secure world to start an attestation
	[]--[]-> [TOSW(~appId,~iid,~deviceId,nonce,packagename,content,appSignature)];

	//[TOAPPS(~appId,~iid,<secret, secretSignature,verify(secretSignature,secret,secretPk)>)]--[]->[];

	//event SecretReceivedVerfied(secret, verify(secretSignature,secret,secretPk));
	0

let HonestAppInstalltion =
	event Checked('HonestAppInstalltion');
	//install an application
	[!App_Published(devId,packagename,content,appSignature,secretPk)]--[]-> [];

	event Application_Installed(~deviceId,packagename,content,appSignature);

	!KeyApp

let ArbitraryApp =
    //receive a nonce
	in(nonce);

	event NonceRecieved(nonce);
	new ~iid;
	//attestation_agent send app data to secure world to start an attestation
	[]--[]-> [TOSW(~appId,~iid,~deviceId,nonce,packagename,content,appSignature)];
	0


let ArbitraryAppInstalltion =
	event Checked('ArbitraryAppInstalltion');
	//install an application
	in(<packagename,content>);
	new ~hash;
	let appSignature = ~hash in

	event Application_Installed(~deviceId,packagename,content,appSignature);

    !ArbitraryApp
	

let AppInstallation =
	new ~appId;
	(HonestAppInstalltion + ArbitraryAppInstalltion)

let Device =

	//Create device reference
	new ~deviceId;

	//send the device refernece , allows an advsery to tamper the device
	out(~deviceId);
	
	let status = 'valid' in
	//setup a secureWorld
	[]--[]-> [SetUPSW(~deviceId,status)];
	[FinishSetUPSW(~deviceId)]--[]->[];
	event A_finished();

	!AppInstallation


/***************************************** Knox V3 *****************************************/

let AtServerKA =
	new ~rootSk;
	let rootCertificate = create_certificate('TbsInfo',pk(~rootSk),~rootSk) in

	//share root certficate	
	[]--[]->
	[
		!RequestCreatingIntermediateCertificate(~rootSk,rootCertificate),
		!GetRootCertificate(rootCertificate)
	];

	!(
		event T_finish() 
	)

let UnlockBootloader =
	[SetUPSW(deviceId,status)]--[]->[];
	if not(status = 'invalid') then
		[]--[]->[SetUPSW(deviceId,'invalid')];
		0

let KeyMasterTA =

	//setup a Secureworld
	[SetUPSW(deviceId,status)]--[]->[FinishSetUPSW(deviceId)];
	
	in(customSoftwareMeasurement);
	
	//Request attestation server
	[!RequestCreatingIntermediateCertificate(rootSk,rootCertificate)]--[]->[];
	
	//Create keymaster certficate
	new ~keymasterSk;
	let  intermediateCertificate = create_certificate('TbsKeyStoreInfo',pk(~keymasterSk),rootSk) in

	!(
		//attestation_agent send app data to secure world, start an attestation
		[TOSW(appId,iid,deviceId,nonce,packagename,content,appSignature)]--[]->[];

		new ~key;

		new ~atId;
		event Attestating_App(~atId,packagename,appSignature,deviceId);

		let hardwareMeasurement = status in
		let softwareMeasurement = customSoftwareMeasurement in
		let subjectCertificate = create_certificate(<~atId,hardwareMeasurement,nonce,packagename,appSignature,deviceId>,pk(~key),~keymasterSk) in
		let certificateChain = <subjectCertificate, intermediateCertificate, rootCertificate> in 
		//send attestation report to the app
		event DeviceStatus(~atId,deviceId,hardwareMeasurement);
		event CreateCert(certificateChain);
		out(certificateChain);
		
		//retrive cipher
		// in(aenc(<secret,secretSignature>,pk(~key)));
		// event SecretReceived(secret);

		// []--[]->[TOAPPS(appId,iid,<secret, secretSignature,true>)];

		event S_finish();


		0

			
	)


let DevServerKA =

	//creating and publising the application
	new ~secret;
	//event SecretGenerted(secret);
	new ~secretSk;
	new ~advk;
	new ~content;
	new ~packagename;
	let appSignature = sign(~advk, <~packagename,~content>) in
	let app = <~packagename,~content,appSignature> in
	out(<app,pk(~secretSk)>);
	event App_Created(~packagename,appSignature);

	new ~devId;
	[]--[]-> [!App_Published(~devId,~packagename,~content,appSignature,pk(~secretSk))];
	!(
	
		// create a nonce
		new ~nonce;
		event NonceGenerated(~nonce);
        new ~requestID;
        event RequestCert(~requestID);
		[]--[]-> [Nonce_Sent(~devId,~nonce)];
		out(~nonce);
		
		//retrieve blob from clients
		in(<<<atId,hardwareMeasurement,~nonce,fpackagename,fappSignature,deviceId>,subjectPk,subjectSi>, intermediateCertificate, rootCertificate>);
		let subjectTbs = <atId,hardwareMeasurement,~nonce,fpackagename,fappSignature,deviceId> in
		let subjectCertificate = <subjectTbs,subjectPk,subjectSi> in
		[!GetRootCertificate(rootCertificate)]--[]->[];

		let verification1 = verify_certificate(subjectCertificate, intermediateCertificate) in
		let verification2 = verify_certificate(intermediateCertificate, rootCertificate) in
		let verification3 = verify_certificate(rootCertificate, rootCertificate) in

		event CheckVerify(~secret,verification1,verification2,verification3);
		let cipher = ~secret in 
		let secretSignature = sign(~secret,~secretSk) in
		let cipher = aenc(<~secret,secretSignature>,subjectPk) in
		event CipherGenerated(cipher);

		//attestation finished		
		if not(appSignature = fappSignature) | not(~packagename = fpackagename) | not(verification1 = verification2) | not(verification1 = true) then
			event Verdict_app(atId,deviceId,hardwareMeasurement,'invalid');	
			event D_finish('invalid') 
		else
            event AcceptCert(~requestID,<subjectCertificate, intermediateCertificate, rootCertificate>);
			event Verdict_app(atId,deviceId,hardwareMeasurement,'valid');
			out(cipher);
			event D_finish('valid') 


	)

/*************************************** Generic code *************************************************/
	
// Main process starts here

/***************************************** choose a platofrm ***************************************************
* platform				|		SafetyNet			|		KnoxV2		|	KnoxV3			|	Key Attestation
* --------------------------------------------------------------------------------------------------------------
* AttestationAgent		: GooglePlay | SafetyNetTA	|	KnoxV2TA		|	KnoxV3TA		|	KeyMasterTA
* AtServer				:		AtServerSN			|	AtServerKV2		|	AtServerKV3		|	AtServerKA
* DevServer				:		DevServerSN			|	DevServerKV2	|	DevServerKV3	|	DevServerKA
***************************************************************************************************************/


let AttestationAgent =
	KeyMasterTA

let AtServer = 
	AtServerKA

let DevServer = 
	DevServerKA




//create pair attetsation keys to be used by secreworld for sigining, and attestation server for verfication
new ~skAT;

(!Device || !DevServer || AtServer || !AttestationAgent || UnlockBootloader || !Np) 


lemma CertPossible:
  exists-trace 
    "Ex requestID subjectCertificate intermediateCertificate rootCertificate #i #j.
        (AcceptCert(requestID,<subjectCertificate, intermediateCertificate, rootCertificate>) @i
        & RequestCert(requestID)@j) & #j < #i "


lemma CertFresh:
    "All requestID subjectCertificate intermediateCertificate rootCertificate #i.
        AcceptCert(requestID,<subjectCertificate, intermediateCertificate, rootCertificate>) @i
            ==>   Ex #j. RequestCert(requestID)@j
			    & Ex #k. CreateCert (<subjectCertificate, intermediateCertificate, rootCertificate>)@k
			    & #j < #k & #k < #i" 





// for all valid attestation => (device must be not rooted and app must be not repacked).
lemma DeviceAndAppIntegrity:
	"(All atId deviceId #i. Verdict_app(atId,deviceId,'valid','valid') @ i ==> 
	( 
	(Ex #j. DeviceStatus(atId,deviceId,'valid') @ j & j < i) 
	& (Ex packagename appSignature #j #k. 
			 App_Created(packagename,appSignature) @ j 
			 & Attestating_App(atId,packagename,appSignature,deviceId)@ k)
	))"


// for all failed application integrity check only  => (device must be valid and there an app created, an app attested and either the hash is different or packagename).
lemma RepackedAppIntegrity:
	"(All atId deviceId #i. Verdict_app(atId,deviceId,'valid','invalid') @ i ==> 
	( 
	(Ex #j. DeviceStatus(atId,deviceId,'valid') @ j & j < i) 
	& (Ex packagename fpackagename appSignature fappSignature #j #k. 
			 App_Created(packagename,appSignature) @ j 
			 & Attestating_App(atId,fpackagename,fappSignature,deviceId)@ k
			 & (
					(not(appSignature = fappSignature))
					| (not(packagename = fpackagename))
			 	)
			 
		)
	))"

// lemma CheckVerifyCerts:
// exists-trace
// 	"Ex secret #i #j #k. 
// 		CheckVerify(secret,true,true,true)@i 
// 		& SecretReceived(secret)@j
// 		& SecretReceivedVerfied(secret,true)@k"

lemma CheckCipher:
exists-trace
			"Ex cipher #i #j. 
				CipherGenerated(cipher)@i 
				& CipherReceived(cipher)@j"	
		
lemma UniqueNonce:
	"All n #i #j. NonceGenerated(n) @i & NonceGenerated(n) @j ==> #i=#j"

	
//Sanity check: Attestation finished
lemma Correctness_Both_Valid:
exists-trace
	"Ex atId deviceId #i. Verdict_app(atId,deviceId,'valid','valid') @ i"

//Sanity check: Attestation finished
lemma Correctness_Rooting_Device:
exists-trace
	"Ex atId any deviceId #i. Verdict_app(atId,deviceId,'invalid',any) @ i"


lemma Correctness_DH:
	exists-trace
		"Ex #i. D_finish('valid') @ i"

lemma Correctness_TV:
exists-trace
	"Ex #i. Checked('HonestAppInstalltion') @ i"

lemma Correctness_TI:
exists-trace
	"Ex #i. Checked('ArbitraryAppInstalltion') @ i"
	
end