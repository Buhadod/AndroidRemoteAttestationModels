theory KnoxV2_TLS
begin

builtins: asymmetric-encryption, signing, hashing, symmetric-encryption

/* We formalize the following protocol

    1. App -> Developer      : request N_v
    2. Developer -> Vender   : request N_v
    3. Vender -> Developer   : N_v, apikey
    4. Developer -> App      : N_v, apikey
    5. App -> SecWorld       : N_v
    6. SecWorld -> App       : statement = <N_s, measurement, deviceID>, E_venderPubKey(Sign_secWorldSignKey(Stmt),Stmt) i.e (blob)
    7. App -> Developer      : blob, N_s, apikey
    8. Developer -> Vender   : blob, N_s, apikey
    9. Vender -> Developer   : statement
    10. Developer -> App      : secret
*/

/*
  Assumiption:
*/


// Public key infrastructure 
// Registering a public key
rule Register_pk:
    [ Fr(~ltk) ] --> [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]

rule Get_pk:
    [ !Pk(A, pubkey) ] --> [ Out(pubkey) ]

// Compromising an agent's long-term key 
rule Reveal_ltk:
    [ !Ltk(A, ltk) ] --[ LtkReveal(A) ]->[ Out(ltk) ]



/* Set up rules */
rule CreateVender:
  [ 
    Fr(~venderPrivKey)
  ]
  --[ ]->
  [
    !VenderKeys(~venderPrivKey, pk(~venderPrivKey)),
    !VenderInfo(pk(~venderPrivKey))
  ]

rule VenderComprimse:
  [ 
    !VenderKeys(venderPrivKey, venderPubKey)
  ]
  --[ VenderComprimsed(venderPubKey) ]->
  [
    Out(<venderPrivKey, venderPubKey>)
  ]

rule CreateDevice:
  [ 
    Fr(~deviceID), Fr(~secWorldSignKey),
    !VenderKeys(venderPrivKey, venderPubKey)
  ]
  --[ ]->
  [
    !SecureWorldInfo(~deviceID,venderPubKey,~secWorldSignKey),
    !VenderDevicesInfo(venderPrivKey, ~secWorldSignKey, ~deviceID) 
  ]

rule SecWorldComprimse:
  [ 
    !SecureWorldInfo(deviceID,venderPubKey,~secWorldSignKey)
  ]
  --[ SecWorldComprimsed(deviceID) ]->
  [
    Out(<deviceID>)
  ]

  rule CreateDeveloper:
  [ 
    Fr(~apiKey),
    !VenderInfo(venderPupKey)
  ]
  --[ ]->
  [
    !DeveloperInfo(venderPupKey, ~apiKey), 
    !VenderDeveloperInfo(venderPupKey, ~apiKey)
  ]

rule DevComprimse:
  [ 
    !DeveloperInfo(venderPupKey, apiKey)
  ]
  --[ DevComprimsed(apiKey) ]->
  [
     Out(<apiKey>)
  ]


  rule CreateApp:
  [
    Fr(~appSHA), Fr(~secret),
    !DeveloperInfo(venderPupKey, apiKey)
  ]
  --[ ]->
  [
    !AppInfo(~appSHA,~secret, apiKey)
  ]

/* Installation rules*/

rule Install_App_in_Device:
  [
    !AppInfo(appSHA,secret, apiKey),
    !SecureWorldInfo(deviceID,venderPubKey,secWorldSignKey)
  ]
  --[ Install_App_in_Device(appSHA,secret, apiKey, deviceID)]->
  [
      !AppInfoInDevice(appSHA, apiKey, deviceID)
  ]

/*
rule Install_Repacked_App_in_Device:
  [
    !AppInfo(appSHA,secret, apiKey),
    Fr(~fakeAppSHA),
    !SecureWorldInfo(deviceID,venderPubKey,secWorldSignKey)
  ]
  --[ Install_App_in_Device(~fakeAppSHA,secret, apiKey, deviceID)]->
  [
      !AppInfoInDevice(fakeAppSHA, apiKey, deviceID)
  ]
*/

/* Protocol rules*/
rule App_to_Dev_1:
    [ 
      Fr(~kd) , !Pk($D, pkD)  // Create Session key ~k with Server $S
    ]      
  -->
    [ 
      Client_1_App_to_Dev_1( $D, ~kd ) , Out( aenc(~kd, pkD) ) // send the session key ~k to Server $S
    ] 

rule Dev_to_Ven_2:
    let
      request = aenc(kd, pk(~ltkD))      
    in
    [ 
      !Ltk($D, ~ltkD)  , In( request ),  // recieve a request from the client as Server $S
       Fr(~kv) , !Pk($V, pkV)            // create Session key ~kv with Server $V
    ]      
  --[ AnswerRequest($D, kd) ]->           
    [ 
      Server_1_App_to_Dev_1($D, kd),    // Save the session key
      Client_1_Dev_to_Ven_2($V, ~kv ) , Out( aenc(~kv, pkV) ) // send the session key ~kv to Server $V

    ]         

rule Ven_to_Dev_3:
    let
      request = aenc(kv, pk(~ltkV))      
    in
    [ 
      !Ltk($V, ~ltkV) , In( request ),  // recieve a request from the client as Server $S
      Fr(~nv),
      !VenderDeveloperInfo(venderPupKey, apiKey)
    ]
  --[ 
       St_Vendor_to_Developer_3(~nv, apiKey),
       AnswerRequest($V, kv) 
    ]->
    [ 
      Out( <senc(<~nv, apiKey>,kv)> )
    ]

rule Dev_to_App_4:
    let 
      response = senc(<nv, apiKey>,kv)
    in
    [  
      Client_1_Dev_to_Ven_2(V, kv ) , In( response ),
      Server_1_App_to_Dev_1(D, kd),
      !DeveloperInfo(venderPupKey, apiKey)
    ]
  --[ 
      St_Developer_to_App_4(nv, apiKey, V, kv), SessKeyC( V, kv )
    ]->
    [ 
      Out( senc(<nv, apiKey>,kd) ),
      Developer_to_App(nv,apiKey)
    ]

rule App_to_SecWorld_5:
    let 
      response = senc(<nv, apiKey>,kd)
    in
    [  
      Client_1_App_to_Dev_1(D, kd ) , In( response ),
      !AppInfoInDevice(appSHA, apiKey, deviceID)
    ]
  --[ 
      St_App_to_SecWorld_5(nv, appSHA, apiKey, deviceID, D, kd), SessKeyC( D, kd )
    ]->
    [ 
      !Secure_Channel_App_to_SecWorld(nv, appSHA, deviceID),
      AppInfo_2(nv, appSHA, apiKey)
    ]

rule SecWorld_to_App_6:
    
    let blob = aenc(sign (<'NotRooted',nv, deviceID>,secWorldSignKey), venderPubKey)

    in
    [
      !Secure_Channel_App_to_SecWorld(nv, appSHA, deviceID),
      !SecureWorldInfo(deviceID,venderPubKey,secWorldSignKey)
    ]
  --[ 
      St_SecWorld_to_App_6(blob, nv, appSHA, deviceID)
    ]->
    [ 
      !SecWorld_to_App(blob)
    ]

rule App_to_Dev_7:
    [
      Fr(~kd) , !Pk($D, pkD),  // Create Session key ~kd with Server $D
      !SecWorld_to_App(blob),
      AppInfo_2(nv, appSHA, apiKey)
    ]
  --[ 
      St_App_to_Dev_7(nv, blob, appSHA,apiKey, $D, ~kd)
    ]->
    [ 
      Client_1_App_to_Dev_7( $D, ~kd ) , Out( aenc(<~kd,blob, nv, apiKey>, pkD) ) // send the session key ~kd to Server $D
    ]

rule Dev_to_Ven_8:
  let
      request = aenc(<kd,blob, nv, apiKey>, pk(~ltkD))      
    in
    [ 
      !Ltk($D, ~ltkD)  , In( request ),  // recieve a request from the client as Server $S
       Fr(~kv) , !Pk($V, pkV),            // create Session key ~kv with Server $V
       Developer_to_App(nv,apiKey)
    ]
  --[ 
      St_App_to_Dev_8(nv, blob, apiKey, $D, kd), AnswerRequest($D, kd)
    ]->
    [ 
      Server_1_App_to_Dev_7($D, kd),    // Save the session key
      Client_1_Dev_to_Ven_8($V, ~kv ) , Out( aenc(<~kv,blob, nv, apiKey>, pkV) ) // send the session key ~kv to Server $V
    ]

rule Ven_to_Dev_9:
    
    
    let 
      request = aenc(<kv,blob, nv, apiKey>, pk(~ltkV))
      blob = aenc(sign (<'NotRooted',nv, deviceID>,secWorldSignKey), venderPubKey)

    in
    [
      !Ltk($V, ~ltkV) , In( request ),
      !VenderDeveloperInfo(venderPubKey, apiKey),
      !VenderKeys(venderPrivKey, venderPubKey),
      !VenderDevicesInfo(venderPrivKey, secWorldSignKey, deviceID) 
    ]
  --[ 
      St_Ven_to_Dev_9('NotRooted',blob, nv, deviceID), AnswerRequest($V, kv) 
    ]->
    [ 
      Out(senc(<'NotRooted',nv, deviceID, apiKey>, kv))
    ]

rule Dev_to_App_10:
    let 
      response = senc(<'NotRooted',nv, deviceID, apiKey>,kv)
    in
    [  
      Client_1_Dev_to_Ven_8(V, kv ) , In( response ),
      Server_1_App_to_Dev_7(D, kd),
      !AppInfo(appSHA,secret, apiKey),
      !DeveloperInfo(venderPupKey, apiKey)
    ]
  --[ 
      St_Dev_to_App_10(nv, apiKey, secret), SessKeyC( V, kv )
    ]->
    [ 
      Out(senc(<secret,apiKey>, kd))
    ]

rule App_11:
    let 
      response = senc(<secret, apiKey>,kd)
    in
    [  
      Client_1_App_to_Dev_7(D, kd ) , In( response )
    ]
  --[ 
      St_App_11(secret, apiKey), SessKeyC( D, kd )
    ]->
    [
    ]


lemma types [sources]:
  " (All nv apiKey V kv #i .
      St_Developer_to_App_4(nv, apiKey, V, kv) @ i
      ==> (Ex #j. St_Vendor_to_Developer_3(nv, apiKey, V, kv) @ j & #j < #i)
        | (Ex #k. KU(<nv, apiKey, V, kv>) @ k & #k < #i)
        
    )
    "
lemma executable:
  exists-trace 
  " Ex #i #j nv apiKey secret blob deviceID.
      St_Dev_to_App_10(nv, apiKey, secret) @ #i 
      & St_Ven_to_Dev_9('NotRooted',blob, nv, deviceID) @ #j
      & j < i
      "

lemma Client_session_key_secrecy:
  " /* It cannot be that a  */
    not(
      Ex S k #i #j.
        /* client has set up a session key 'k' with a server'S' */
        SessKeyC(S, k) @ #i
        /* and the adversary knows 'k' */
      & K(k) @ #j
        /* without having performed a long-term key reveal on 'S'. */
      & not(Ex #r. LtkReveal(S) @ r)
    )
  "

lemma Client_auth:
  " /* For all session keys 'k' setup by clients with a server 'S' */
    ( All S k #i.  SessKeyC(S, k) @ #i
       ==>
         /* there is a server that answered the request */
       ( (Ex #a. AnswerRequest(S, k) @ a)
         /* or the adversary performed a long-term key reveal on 'S'
            before the key was setup. */
       | (Ex #r. LtkReveal(S) @ r & r < i)
       )
    )
  "

lemma Client_auth_injective:
  " /* For all session keys 'k' setup by clients with a server 'S' */
    ( All S k #i.  SessKeyC(S, k) @ #i
       ==>
         /* there is a server that answered the request */
       ( (Ex #a. AnswerRequest(S, k) @ a
           /* and there is no other client that had the same request */
           & (All #j. SessKeyC(S, k) @ #j ==> #i = #j)
       )
         /* or the adversary performed a long-term key reveal on 'S'
            before the key was setup. */
       | (Ex #r. LtkReveal(S) @ r & r < i)
       )
    )
  "

lemma Client_session_key_honest_setup:
  exists-trace
  " Ex S k #i.
        SessKeyC(S, k) @ #i
      & not(Ex #r. LtkReveal(S) @ r)
  "

end