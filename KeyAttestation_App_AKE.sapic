/*******************************************************************************
	Attested key exchange (AKE) protocol - based on Key attestation
	AUTHORS
	
	
*******************************************************************************/

theory Framework_KeyAttestation_AKE
begin

builtins: signing, asymmetric-encryption, locations-report

heuristic: S

predicates:
Report(x,y) <=> not  (fst(y)= 'loc')

functions: 
	create_certificate/3, verify_certificate/2 , get_tbsInfo_certificate/1, equal/2, and/2

equations:

    create_certificate(SubjectTBSCertificateInfo,SubjectPup,IssuerSk) 
      = < SubjectTBSCertificateInfo, SubjectPup, sign(<SubjectTBSCertificateInfo, SubjectPup>,IssuerSk) >,

    verify_certificate( 
    < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
     , < IssuerTBSCertificateInfo, pk(IssuerSk), sign(<IssuerTBSCertificateInfo, pk(IssuerSk)>,IssuerRootSk) >
          ) = true,

    get_tbsInfo_certificate( 
        < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
          ) = SubjectTBSCertificateInfo,
	
	equal(x,x)=true,
	and(true,true)= true
      
      


/***************************************** Generic *****************************************/

let AppCode = 

	in(nonce);

	event NonceReceivedAtApp(nonce);

	//attestation_agent send app data to secure world to start an attestation
	new ~sessionID;
	new ~k; //shared symmetric key // generated by third-party (other than Android keystore)

	[]--[]-> [SecureWorld_Ch_In(~sessionID,~deviceId,swId,nonce,'App1PackageName','App1Content',sign(<'App1PackageName','App1Content',pk(advk)>,advk),pk(advk),pkV,~k)];
	[ SecureWorld_Ch_Out(~sessionID,certificateChain,fk,signature,cipher)]--[]-> [];
	out(cipher);

	event Checked('HonestAppFinished');

	0


let HonestAppInstallation =
	event Checked('HonestAppInstallation');
	//install an application
	[!App_Published(devId,
		<
		'App1PackageName',
		<'App1Content',pkV> ,
		pk(advk),
		sign( <'App1PackageName',<'App1Content', pkV >,pk(advk)>,advk)
		>
		
		)]--[]-> [];

	event Application_Installed(~deviceId,'App1PackageName',sign( <'App1PackageName','App1Content',pk(advk)>,advk));

	!AppCode 

let ArbitraryAppCode =

	in(<nonce,pkV,k>);
	event NonceReceivedAtArbApp(nonce);
	//attestation_agent send app data to secure world to start an attestation
	new ~sessionID;

	[]--[]-> [SecureWorld_Ch_In(~sessionID,~deviceId,swId,nonce,packagename,~content,appSignature,pk(devKey),pkV,k)];
	[ SecureWorld_Ch_Out(~sessionID,certificateChain,fk,signature,cipher) ]--[]-> [];
	out(<certificateChain,fk,signature,cipher>);

	event Checked('ArbitraryAppFinished');
	0


let ArbitraryAppInstallation =

	event Checked('ArbitraryAppInstallation');
	//install an application
	in(<packagename, devKey>); 

	new ~content;

	let appSignature = sign(<packagename,~content,pk(devKey)>,devKey) in
	let app = <packagename,~content,pk(devKey),appSignature> in
	out(app);
	event Arbitrary_App_Created(packagename,appSignature);
	event Application_Installed(~deviceId,packagename,appSignature);

	!ArbitraryAppCode
	

let Device =

	//Create device reference
	new ~deviceId; 

	//send the device reference , allows an adversary to tamper the device
	out(~deviceId);
	
	//setup a secureWorld
	[]--[]-> [SetUPSW(~deviceId)];
	[FinishSetUPSW(~deviceId,swId)]--[]->[];
	event Checked('SettingUpDeviceFinished');

	(!HonestAppInstallation | !ArbitraryAppInstallation)


/***************************************** Knox V3 *****************************************/

let AtServerKA =
	new ~rootSk;
	let rootCertificate = create_certificate('TbsInfo',pk(~rootSk),~rootSk) in

	//share root certficate	
	[]--[]->
	[
		!RequestCreatingIntermediateCertificate(~rootSk,rootCertificate),
		!GetRootCertificate(rootCertificate)
	];

	!(
		event Checked('AttestationServerFinished')
	)


let KeyMasterTA =

	(
	new ~swId; // We have different secure world and device ID, because it's possible to make different devices have the same ID, therefore 

	//setup a SecureWorld
	[SetUPSW(deviceId)]--[]->[FinishSetUPSW(deviceId,~swId)];

	
	//Request attestation server
	[!RequestCreatingIntermediateCertificate(rootSk,rootCertificate)]--[]->[];
	
	//Create keymaster certficate
	new ~keymasterSk;
	let  intermediateCertificate = create_certificate('TbsKeyStoreInfo',pk(~keymasterSk),rootSk) in

	//attempt to unlock bootloader
	in(attempt);

	!(
		//attestation_agent send app data to secure world, start an attestation
		[SecureWorld_Ch_In(sessionID, deviceId,~swId,nonce,packagename,content,appSignature,devPk,pkV,k)]--[]->[];

		new ~key; //subject key
		
		new ~atId;
		event Attestating_App(~atId,packagename,devPk,deviceId);

		if attempt = 'unlockBootloader' then
			let hardwareMeasurement = 'invalid' in
			//let softwareMeasurement = customSoftwareMeasurement in
			in(<fnonce,fpackagename,fdevPk,fpkV,fk>);	// adversary's custom softeware-based values
			let subjectCertificate = create_certificate(<~atId,hardwareMeasurement,fnonce,fpackagename,fdevPk>,pk(~key),~keymasterSk) in
			let certificateChain = <subjectCertificate, intermediateCertificate, rootCertificate> in 
			//send attestation report to the app
			event DeviceStatus(~atId,deviceId,hardwareMeasurement);
			event Attestating_App_Device(~atId,deviceId,packagename,appSignature,hardwareMeasurement);
            event CreateCert(certificateChain);

			let signature = sign(fk,~key) in
			let cipher = aenc(<certificateChain,fk,signature>,fpkV) in
			out(<certificateChain,fk,signature>);

			[]--[]->[ SecureWorld_Ch_Out(sessionID,certificateChain,k,signature,cipher)  ];
			event Checked('SecureWorldAppFinished_rooted_device')
			
		else
			let hardwareMeasurement = 'valid' in
			//let softwareMeasurement = 'valid' in
			let subjectCertificate = create_certificate(<~atId,hardwareMeasurement,nonce,packagename,devPk>,pk(~key),~keymasterSk) in
			let certificateChain = <subjectCertificate, intermediateCertificate, rootCertificate> in 
			//send attestation report to the app
			event DeviceStatus(~atId,deviceId,hardwareMeasurement);
			event Attestating_App_Device(~atId,deviceId,packagename,appSignature,hardwareMeasurement);
            event CreateCert(certificateChain);
			
			let signature = sign(k,~key) in
			let cipher = aenc(<certificateChain,k,signature>,pkV) in

			[]--[]->[ SecureWorld_Ch_Out(sessionID,certificateChain,k,signature,cipher) ];
			event Checked('SecureWorldAppFinished_locked_device')
	
			
	)
	)@<'loc',pk(~skAT)>



let DevServerProtocolCode =
	
		// create a nonce
		new ~nonce;
		event NonceGenerated(~nonce);
        new ~requestID;
        event RequestCert(~requestID);
		out(~nonce);
		
		//aenc(<certificateChain,~k,signature>,pkV)
		//retrieve blob from clients
		in(
			aenc(<
					<<<atId,hardwareMeasurement,~nonce,fpackagename,fdevPk>,subjectPk,subjectChain>, intermediateCertificate, rootCertificate>,
					k,
					signature
				 >,pk(~skV)
				)	
			);
		let certificateChain = <<<atId,hardwareMeasurement,~nonce,fpackagename,fdevPk>,subjectPk,subjectChain>, intermediateCertificate, rootCertificate> in
		let subjectTbs = <atId,hardwareMeasurement,~nonce,fpackagename,fdevPk> in
		let subjectCertificate = <subjectTbs,subjectPk,subjectChain> in
		[!GetRootCertificate(rootCertificate)]--[]->[];
		
		event NonceReceived(~nonce);

		let KeyVerfication = verify(signature,k,subjectPk) in

		//verify certificate chain
		let verfication = and(
			verify_certificate(subjectCertificate, intermediateCertificate),
			verify_certificate(intermediateCertificate, rootCertificate)
		) in

		let verfication = and(verfication, KeyVerfication) in

		//checking app information
		let appCertificateCheck = equal(pk(~advk) , fdevPk) in
		let packagenameCheck = equal(packagename, fpackagename) in
		let result = and(appCertificateCheck, packagenameCheck) in


		if verfication = true then
			if result = true  then
				event AcceptCert(~requestID,<subjectCertificate, intermediateCertificate, rootCertificate>);
				event Verdict_app(atId,certificateChain,'valid',hardwareMeasurement,'valid',k);
				event Checked('DeveloperServerfinished_valid')
				
			else
				event Verdict_app(atId,certificateChain,'valid',hardwareMeasurement,'invalid',k);
				event Checked('DeveloperServerfinished_invalid')
				
				

	



let DevServerKA =

	
	//Developer key
	new ~skV;
	out(pk(~skV));

	
	//creating and publishing the application
	new ~advk; // Dev server signing key
	new ~devId; 
	let packagename = 'App1PackageName' in
	let appContent = <'App1Content',pk(~skV)> in
	let appSignature = sign(<packagename,appContent,pk(~advk)>,~advk) in 
	let app = <packagename,appContent,pk(~advk),appSignature> in
	out(app);
	event App_Created(packagename,pk(~advk));

	[]--[]-> [!App_Published(~devId,app)];
	


	!DevServerProtocolCode
/*************************************** Generic code *************************************************/
	
// Main process starts here

/***************************************** choose a platofrm ***************************************************
* platform				|		SafetyNet			|		KnoxV2		|	KnoxV3			|	Key Attestation
* --------------------------------------------------------------------------------------------------------------
* AttestationAgent		: GooglePlay | SafetyNetTA	|	KnoxV2TA		|	KnoxV3TA		|	KeyMasterTA
* AtServer				:		AtServerSN			|	AtServerKV2		|	AtServerKV3		|	AtServerKA
* DevServer				:		DevServerSN			|	DevServerKV2	|	DevServerKV3	|	DevServerKA
***************************************************************************************************************/


let AttestationAgent =
	KeyMasterTA

let AtServer = 
	AtServerKA

let DevServer = 
	DevServerKA




//create pair attetsation keys to be used by secreworld for sigining, and attestation server for verfication
new ~skAT;

(!Device || !DevServer || AtServer || !AttestationAgent )


lemma CertPossible:
  exists-trace 
    "Ex requestID subjectCertificate intermediateCertificate rootCertificate #i #j.
        (AcceptCert(requestID,<subjectCertificate, intermediateCertificate, rootCertificate>) @i
        & RequestCert(requestID)@j) & #j < #i "


lemma CertFresh:
    "All requestID subjectCertificate intermediateCertificate rootCertificate #i.
        AcceptCert(requestID,<subjectCertificate, intermediateCertificate, rootCertificate>) @i
            ==>   Ex #j. RequestCert(requestID)@j
			    & Ex #k. CreateCert (<subjectCertificate, intermediateCertificate, rootCertificate>)@k
			    & #j < #k & #k < #i" 

//for all valid verdict => honest apps must created, installed, attested in a valid device and KU does know its attestation report
lemma DeviceAndAppIntegrity:
	"(All atId certificateChain key #i. Verdict_app(atId,certificateChain,'valid','valid','valid',key) @ i ==> 
	( 
	 (Ex deviceId packagename appSignature #a #b #c. 
			 App_Created(packagename,appSignature) @ a
			 & Application_Installed(deviceId,packagename,appSignature) @ b
			 & Attestating_App_Device(atId,deviceId,packagename,appSignature,'valid')@ c & c < i
			 & ( not( Ex #k. KU(key) @ k & k<i ))
			 
		)
	))"

//for all valid verdict =>  Ku should not know its attestation report by any mean
lemma AttestedKeySecrecy:
	"(All atId certificateChain key #i. Verdict_app(atId,certificateChain,'valid','valid','valid',key) @ i ==> 
	 (	not( Ex #k. KU(key) @ k & k<i ) )
	)"

//Check if nonce are unique
lemma UniqueNonce:
	"All n #i #j. NonceReceived(n) @i & NonceReceived(n) @j ==> #i=#j"

//Sanity check: Attestation finished with valid device integirty and application integirty. 
lemma Correctness_Valid_Attestation:
exists-trace
	"Ex atId blob key #i. Verdict_app(atId,blob,'valid','valid','valid',key) @ i"

//Sanity check: Attestation finished with at least failed device integirty
lemma Correctness_Rooting_Device:
exists-trace
	"Ex atId blob key any #i. Verdict_app(atId,blob,'valid','invalid',any,key) @ i"

//Sanity check: Setting up a device's secure world 
lemma Correctness_Setting_Up_Device:
exists-trace
	"Ex #i. Checked('SettingUpDeviceFinished') @ i"
	
//Sanity check: Creation of an honest application 
lemma Correctness_Honest_App:
exists-trace
	"Ex #i. Checked('HonestAppInstallation') @ i"

//Sanity check: Creation of an arbitrary application 
lemma Correctness_Arbitrary_App:
exists-trace
	"Ex #i. Checked('ArbitraryAppInstallation') @ i"

//Sanity check: An honest application can finish
lemma Correctness_Honest_App_Finished:
exists-trace
	"Ex #i. Checked('HonestAppFinished') @ i"
	
//Sanity check: An arbitrary application can finish
lemma Correctness_Arbitrary_App_Finished:
exists-trace
	"Ex #i. Checked('ArbitraryAppFinished') @ i"

//Sanity check: Secure world app can finish in a rooted device
lemma Correctness_Secure_World_Finished_ROOTED:
exists-trace
	"Ex #i. Checked('SecureWorldAppFinished_rooted_device') @ i"

//Sanity check: Secure world app can finish in a locked device
lemma Correctness_Secure_World_Finished_LOCKED:
exists-trace
	"Ex #i. Checked('SecureWorldAppFinished_locked_device') @ i"

//Sanity check: Attestation Server can finish
lemma Correctness_Attestation_Server_Finished:
exists-trace
	"Ex #i. Checked('AttestationServerFinished') @ i"

//Sanity check: Developer server can finish with report from an honest app
lemma Correctness_Developer_Server_Finished_VALID:
exists-trace
	"Ex #i. Checked('DeveloperServerfinished_valid') @ i"

//Sanity check: Developer server can finish with report from an arbitrary app
lemma Correctness_Developer_Server_Finished_INVALID:
exists-trace
	"Ex #i. Checked('DeveloperServerfinished_invalid') @ i"
end

==============================================================================
summary of summaries:

analyzed: KeyAttestation_App_AKE.sapic

  CertPossible (exists-trace): verified (8 steps)
  CertFresh (all-traces): verified (122 steps)
  UniqueNonce (all-traces): verified (8 steps)
  Correctness_Valid_Attestation (exists-trace): verified (6 steps)
  Correctness_Rooting_Device (exists-trace): verified (8 steps)
  Correctness_Setting_Up_Device (exists-trace): verified (4 steps)
  Correctness_Honest_App (exists-trace): verified (4 steps)
  Correctness_Arbitrary_App (exists-trace): verified (4 steps)
  Correctness_Honest_App_Finished (exists-trace): verified (4 steps)
  Correctness_Arbitrary_App_Finished (exists-trace): verified (4 steps)
  Correctness_Secure_World_Finished_ROOTED (exists-trace): verified (4 steps)
  Correctness_Secure_World_Finished_LOCKED (exists-trace): verified (4 steps)
  Correctness_Attestation_Server_Finished (exists-trace): verified (4 steps)
  Correctness_Developer_Server_Finished_VALID (exists-trace): verified (8 steps)
  Correctness_Developer_Server_Finished_INVALID (exists-trace): verified (8 steps)

==============================================================================