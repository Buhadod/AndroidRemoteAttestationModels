theory ProposedModel
begin

builtins: signing , asymmetric-encryption

functions: 
  create_certificate/3, verify_certificate/2 , get_tbsInfo_certificate/1, get_public_key_certificate/1

equations:
    create_certificate(SubjectTBSCertificateInfo,SubjectPup,IssuerSk) 
      = < SubjectTBSCertificateInfo, SubjectPup, sign(<SubjectTBSCertificateInfo, SubjectPup>,IssuerSk) >,

    verify_certificate( 
    < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
     , < IssuerTBSCertificateInfo, pk(IssuerSk), sign(<IssuerTBSCertificateInfo, pk(IssuerSk)>,IssuerRootSk) >
          ) = true,

    get_tbsInfo_certificate( 
        < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
          ) = SubjectTBSCertificateInfo,

    get_public_key_certificate( 
      < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
          ) = pk(SubjectSk)
/*

Fr(~root), 
certificate = sign(pk(~root),~root)
*/

/*
 * Protocol:     Key attesation
 * Modeler:      Code protection project
 * Described in: https://developer.android.com/training/articles/security-key-attestation
 *               https://source.android.com/security/keystore/attestation
 * Figure        Based on figures/b.pdf
 * Date:         July 2021
 *
 * Status:       working
 */

/* We formalize the following protocol



*/


/* Set up rules */
rule RepackProcess:
  let 
    repackedApk = <appPackage,'sourcecode','resources'>
    SelfsignAppSignature = sign( repackedApk,~DebugKey)
  in  
  [ 
    !App(appPackage,appSignature),
    Fr(~DebugKey)
  ]
  --[ RepackeApp(appPackage)]->
  [
    !App(appPackage,SelfsignAppSignature),
    !GetDebugKey(~DebugKey,appPackage)
  ]

rule CreateApplication:
  let 
      appPackage = 'appPackage'
      apk = <appPackage,'sourcecode','resources'> 
      appSignature = sign(apk,~DeveloperKey)
  in
  [
    Fr(~DeveloperKey)
  ]
  --[ CreateApp(appPackage)]->
  [
    !App(appPackage,appSignature),
    !GetDeveloperKey(~DeveloperKey,appPackage)
  ]

rule CreateAttestionServer:
  let 
    rootCertificate = create_certificate('TbsInfo',pk(~rootSk),~rootSk)
  in
  [
    Fr(~rootSk)
  ]
  --[]->
  [
    !GetRootCertificate(rootCertificate),
    !RequestCreatingIntermediateCertificate(~rootSk,rootCertificate)
  ]

rule CreateDevice:
  let 
    software_measurement = 'valid' 
    hardware_measurement = 'valid' 
    intermediateCertificate = create_certificate('TbsKeyStoreInfo',pk(~keystoreSk),~rootSk)
    certificateChain = <intermediateCertificate, rootCertificate>
  in
  [ 
    Fr(~keystoreSk),
    Fr(~dev_id),
    !RequestCreatingIntermediateCertificate(~rootSk,rootCertificate)
    
  ]
  --[ KeyGenerated(~rootSk,~dev_id),  KeyStoreCertificateGenerated(intermediateCertificate)]->
  [
    !Device(~dev_id,~keystoreSk,software_measurement,hardware_measurement,certificateChain)
  ]


rule CreateUnlockedBootloaderDevice:
  let 
    hardware_measurement = 'invalid' 
    intermediateCertificate = create_certificate('TbsKeyStoreInfo',pk(~keystoreSk),~rootSk)
    certificateChain = <intermediateCertificate, rootCertificate>
  in
  [ 
    Fr(~keystoreSk),
    Fr(~dev_id),
    In(<fake_measurement>),
    !RequestCreatingIntermediateCertificate(~rootSk,rootCertificate)
  ]
  --[ KeyGenerated(~rootSk,~dev_id), KeyStoreCertificateGenerated(intermediateCertificate)]->
  [
    !Device(~dev_id,~keystoreSk,fake_measurement,hardware_measurement,certificateChain)
  ]


/* Protocol rules*/
rule Dvr_to_App_1:
    [
      Fr(~nonce)
    ]
  --[NonceGenerated(~nonce)]->
    [ 
      Out(~nonce),
      DeveloperCreateNonce(~nonce)
    ]


rule App_to_SecW_2:
    [
      In(nonce),
      !App(appPackage,appSignature),
      //create attestation session id (sid)
      Fr(~sid),
      Fr(~app_id)
    ]
  --[ AppInstalled(~app_id, appPackage) ]->
    [ 
      PrivateChannelB('secureChannel',<~sid,nonce,appPackage,appSignature,~app_id>),
      SaveAppIntegritySession(~sid,~app_id,appPackage,appSignature)
    ]

rule SecW_to_App3:
    let 
      subjectCertificate = create_certificate(<nonce,software_measurement,hardware_measurement,appPackage,appSignature>,pk(~key),keystoreSk)
      certificateChain = <subjectCertificate, intermediateCertificate, rootCertificate>
    in
    [
      PrivateChannelB('secureChannel', <sid,nonce,appPackage,appSignature,app_id> ),
      !Device(dev_id,keystoreSk,software_measurement,hardware_measurement,<intermediateCertificate,rootCertificate>),
      Fr(~key)
      
    ]
  --[CertificateChainGenerated(certificateChain,app_id,dev_id) ]->
    [ 
      PrivateChannelC('secureChannel', <sid,certificateChain>),
      SaveDeviceIntegritySession(sid,app_id,appPackage,appSignature,software_measurement,hardware_measurement),
      SaveTEEInfo(sid,~key)
    ]

rule App_to_Dvr4:
    [
      PrivateChannelC('secureChannel',<sid,certificateChain>),
      //Get app integrity check
      SaveAppIntegritySession(sid,app_id,appPackage,appSignature)
    ]
  --[]->
    [ 
      Out(<sid,certificateChain>)
    ]



rule Dvr_verification_5:
    let 
      //chain certificate verfication
      verification1 = verify_certificate(subjectCertificate, intermediateCertificate)
      verification2 = verify_certificate(intermediateCertificate, rootCertificate)
      verification3 = verify_certificate(rootCertificate, rootCertificate)
      tbsInfo = get_tbsInfo_certificate(subjectCertificate)
      ppk = get_public_key_certificate(subjectCertificate)
    in
    [
      In(<sid,<subjectCertificate, intermediateCertificate, rootCertificate>> ),
      !GetRootCertificate(rootCertificate)
    ]
  --[Debug()]->
    [ 
      PrivateChannelF('verification',<sid,ppk,verification1,verification2,verification3,<tbsInfo>>)
    ]

rule Dvr_to_App_7:
    let
      apk = <appPackage,'sourcecode','resources'>
    in
    [
      !GetDeveloperKey(DeveloperKey,appPackage),
      DeveloperCreateNonce(nonce),
      PrivateChannelF('verification',<sid,ppk,true,true,true,<nonce,'valid','valid',appPackage,sign(apk,DeveloperKey)>>),
      Fr(~secret)
    ]
  --[ SecretGenerated(~secret),Debug2()]->
    [ 
      Out(<sid,aenc(~secret,ppk)>)
    ]

rule App_to_Sw_8:
    [
      In(<sid,encrypted_cipher_secret>),
      //Get Device integrity from attestation time
      SaveDeviceIntegritySession(sid,app_id,appPackage,appSignature,software_measurement,hardware_measurement)
    ]
  --[ EncryptedSecretReceived(encrypted_cipher_secret),SecretRecievedByApp(app_id)]->
    [
      //LeakSecretIfAppRepacked(appPackage,appSignature,encrypted_cipher_secret),
      //LeakSecretIfDeviceCompomised(hardware_measurement,encrypted_cipher_secret),
      PrivateChannelH('secureChannel',<sid,app_id,encrypted_cipher_secret>)
    ]


rule Sw_to_App_9:
    [
      PrivateChannelH('secureChannel',<sid,app_id,aenc(secret,pk(key))>),
      //Restore TEE info
      SaveTEEInfo(sid,key)

    ]
  --[]->
    [
      PrivateChannelH('secureChannel',<sid,app_id,secret>)
    ]

rule App_from_SW_10:
    [
      PrivateChannelH('secureChannel',<sid,app_id,secret>)
    ]
  --[SecretReceived(app_id), SecretLoaded(secret)]->
    [ 
    ]

//Reachability : Protocal can finish
lemma Prove1: 
  exists-trace 
  "Ex app_id appPackage  #i #j #k #l.
      CreateApp(appPackage) @i
      & AppInstalled(app_id,appPackage) @j
      & SecretRecievedByApp(app_id) @k
      & SecretReceived(app_id) @l
  "

lemma Debug: exists-trace "Ex #i .Debug() @i "

lemma Debug2: exists-trace "Ex #i .Debug2() @i "

//Secret leacked
lemma Prove2: "(not ( Ex secret #i #k. SecretGenerated(secret) @i & KU(secret) @k ))"

//code execution
/*
It is not possibile that there exist  a secret loaded and known by the advsery and never generated
*/
lemma Prove3: "(not ( Ex secret #i #k #j. SecretLoaded(secret) @i & KU(secret) @k ))"



end