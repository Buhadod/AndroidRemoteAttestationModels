theory SafetyNet_KeyAttestation
begin

builtins: symmetric-encryption, signing

/*
 * Protocol:     SafetyNet with key Attestation
 * Modeler:      Code protection project
 * Described in: https://developer.android.com/training/safetynet/attestation#evaluation-types
 * Figure        Based on figures/a.pdf
 * Date:         July 2021
 *
 * Status:       working
 */

/* We formalize the following protocol


*/
rule RepackProcess:
  let 
    SelfsignAppSignature = sign(appPackage,~DebugKey)
  in  
  [ 
    !App(appPackage,appSignature),
    Fr(~DebugKey)
  ]
  --[ RepackeApp(appPackage)]->
  [
    !App(appPackage,SelfsignAppSignature),
    !GetDebugKey(~DebugKey,appPackage)
  ]

rule CreateApplication:
  let 
      appPackage = <'packagename','sourcecode','resources'> 
      appSignature = sign(appPackage,~DeveloperKey)
  in
  [
    Fr(~DeveloperKey)
  ]
  --[ CreateApp(appPackage)]->
  [
    !App(appPackage,appSignature),
    !GetDeveloperKey(~DeveloperKey,appPackage)
  ]


rule CreateDevice:
  let 
  software_measurement = 'valid' 
  hardware_measurement = 'valid' in
  [ 
    Fr(~key),
    Fr(~dev_id)
    
  ]
  --[ KeyGenerated(~key,~dev_id)]->
  [
    !Device(~dev_id,~key,software_measurement,hardware_measurement),
    !Server_SecureWorld(~key)
  ]

rule CreateServer:
  [ 
   
  ]
  --[ ]->
  [
    !Server()
  ]


rule CreateUnlockedBootloaderDevice:
  let 
    hardware_measurement = 'invalid' in
  [ 
    Fr(~key),
    Fr(~dev_id),
    In(<fake_measurement>)
  ]
  --[ KeyGenerated(~key,~dev_id)]->
  [
    !Device(~dev_id,~key,fake_measurement,hardware_measurement),
    !Server_SecureWorld(~key)
  ]

/* Protocol rules*/

rule Dvr_to_App_1:
    [
      Fr(~nonce)
    ]
  --[NonceGenerated(~nonce)]->
    [ 
      PrivateChannelA('deviceChannel', ~nonce),
      DeveloperCreateNonce(~nonce)
    ]

rule App_to_SecW_2:
    [
      !App(appPackage,appSignature),
      //create attestation session id (sid)
      Fr(~sid),
      Fr(~app_id),
      PrivateChannelA('deviceChannel', nonceA )
    ]
  --[ AppReceieveNonce(~app_id, appPackage,nonceA) ]->
    [ 
      PrivateChannelB('secureChannel',<~sid,nonceA,appPackage,appSignature,~app_id>),
      SaveAppIntegritySession(~sid,~app_id,appPackage,appSignature)
    ]

rule SecW_to_App3:
    let 
       blob = senc(<nonceSW,appPackage,appSignature,software_measurement,hardware_measurement>,key) 
    in
    [
      PrivateChannelB('secureChannel', <sid,nonceSW,appPackage,appSignature,app_id> ),
      !Device(dev_id,key,software_measurement,hardware_measurement)
      
    ]
  --[BlobGenerated(blob,app_id,dev_id)  ]->
    [ 
      PrivateChannelC('secureChannel', <sid,blob>),
      SaveDeviceIntegritySession(sid,app_id,appPackage,appSignature,software_measurement,hardware_measurement)
    ]

rule App_to_Dvr4:
    [
      PrivateChannelC('secureChannel',<sid,blob>),
      //Get app integrity check
      SaveAppIntegritySession(sid,app_id,appPackage,appSignature)
    ]
  --[]->
    [ 
      PrivateChannelD('deviceChannel',<sid,blob>),
      
      LeakBlobIfAppRepacked(sid,app_id,appPackage,appSignature,blob)
    ]

rule App_to_Dvr4_Leakage:
  [
    //retrive debug key
    !GetDebugKey(DebugKey,appPackage),
    //check if the app selfsigned
    LeakBlobIfAppRepacked(sid,app_id,appPackage,sign(appPackage,DebugKey),blob)
  ]
  --[BlobLeaked(blob,app_id)]->
  [
    //create partial deconstruction and no needed
    //Out(blob)
  ]

rule Dvr_to_Svr_5:
  [
    PrivateChannelD('deviceChannel',<sid,blob>)
  ]
  --[]->
  [
    PrivateChannelE('deviceChannel',<sid,blob>)
  ]


rule Svr_to_Dvr_6:
    [
      PrivateChannelE('deviceChannel',<sid,senc(<nonceSW,appPackage,appSignature,software_measurement,hardware_measurement>,key)> ),
      !Server_SecureWorld(key)
    ]
  --[]->
    [ 
      PrivateChannelF('deviceChannel',<sid,nonceSW,appPackage,appSignature,software_measurement,hardware_measurement>)
    ]

rule Svr_to_Dvr_7:
    [
      !GetDeveloperKey(DeveloperKey,appPackage),
      PrivateChannelF('deviceChannel',<sid,nonceSW,appPackage,sign(appPackage,DeveloperKey),'valid','valid'> ),
      DeveloperCreateNonce(nonceSW),
      Fr(~secret)
    ]
  --[ NonceReceived(nonceSW), SecretGenerated(~secret)]->
    [ 
      PrivateChannelG(<sid,~secret, nonceSW>)
    ]

rule App_from_Dvr8:
    [
      PrivateChannelG(<sid,secret, nonceSW>),
      //Get Device integrity from attestation time
      SaveDeviceIntegritySession(sid,app_id,appPackage,appSignature,software_measurement,hardware_measurement)
    ]
  --[ SecretReceived(secret)]->
    [
      LeakSecretIfAppRepacked(appPackage,appSignature,secret),
      LeakSecretIfDeviceCompomised(hardware_measurement,secret)
    ]

rule App_from_Svr8_If_Leakage_via_app_repack:
    [
      //retrive debug key
      !GetDebugKey(DebugKey,appPackage),
      //check if the app selfsigned
      LeakSecretIfAppRepacked(appPackage,sign(appPackage,DebugKey),secret)
    ]
  --[ SecretLeaked(secret)]->
    [
      Out(secret)
    ]

rule App_from_Svr8_If_Leakage_via_device_compomised:
    [
      LeakSecretIfDeviceCompomised('invalid',secret)
    ]
  --[ SecretLeaked(secret)]->
    [
      Out(secret)
    ]


//Reachability : Protocal can finish
lemma Prove1: 
  exists-trace 
  "Ex app_id appPackage nonce #i #j #k.
      CreateApp(appPackage) @i
      & AppReceieveNonce(app_id,appPackage, nonce) @j
      & NonceReceived(nonce) @k
  "

//Secret leacked
lemma Prove2: "(not ( Ex secret #i #k. SecretGenerated(secret) @i & KU(secret) @k ))"

end