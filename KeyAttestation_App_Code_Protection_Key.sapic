/*******************************************************************************
	Remote attestation Framework
	AUTHORS
	
	
*******************************************************************************/

theory Framework_KeyAttestation_App_Nonce_CP_Key
begin

builtins: signing, asymmetric-encryption

functions: check_rep/2,  get_rep/1, rep/2 [private], create_certificate/3, verify_certificate/2 , get_tbsInfo_certificate/1

equations:
    check_rep(rep(x.1, x.2), x.2) = true,
    get_rep(rep(x.1, x.2)) = x.1,

    create_certificate(SubjectTBSCertificateInfo,SubjectPup,IssuerSk) 
      = < SubjectTBSCertificateInfo, SubjectPup, sign(<SubjectTBSCertificateInfo, SubjectPup>,IssuerSk) >,

    verify_certificate( 
    < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
     , < IssuerTBSCertificateInfo, pk(IssuerSk), sign(<IssuerTBSCertificateInfo, pk(IssuerSk)>,IssuerRootSk) >
          ) = true,

    get_tbsInfo_certificate( 
        < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
          ) = SubjectTBSCertificateInfo
      


/***************************************** Generic *****************************************/

let AppCode = 
    [Nonce_Sent(devId,nonce)]--[]-> [];

	event NonceRecieved(nonce);

	//attestation_agent send app data to secure world to start an attestation
	new ~sessionID;
	[]--[]-> [TOSW(~sessionID,~deviceId,swId,nonce,'App1PackageName',<'App1Content',cipherContent,secretVPk>,sign( <'App1PackageName',<'App1Content',cipherContent,secretVPk>,pk(advk)>,advk))];
	[ FROMSW(~sessionID,certificateChain) ]--[]-> [];
	out(certificateChain);

	in(cipher);
	
	[]--[]->[TOSW2(~sessionID,cipher)];
	[FROMSW2(~sessionID,<secretESk,signature>,hardwareMeasurement)]--[]->[];

	//check verfication for honest app. if the device already rooted. verfication can be bypassed
	if((verify(signature,secretESk,secretVPk) = true)| (hardwareMeasurement = 'invalid')) then
		event SecretOnlyReceivedAppStatus(~sessionID,secretESk,'valid');
		let content = adec(cipherContent,secretESk) in 
		event SecretReceivedAppStatus(~sessionID,content,secretESk,'valid');
		0		


let HonestAppInstallation =
	event Checked('HonestAppInstallation');
	//install an application
	[!App_Published(devId,
		<'App1PackageName',
		<'App1Content',cipherContent,secretVPk>,
		pk(advk),
	    sign( <'App1PackageName',<'App1Content',cipherContent,secretVPk>,pk(advk)>,advk)
		>)]--[]-> [];

	event Application_Installed(~deviceId,'App1PackageName',<'App1Content',cipherContent>,sign(advk, <'App1PackageName',<'App1Content',cipherContent>,pk(advk)>));

	!AppCode 

let ArbitraryAppCode =

	in(nonce);
	event NonceReceived(nonce);
	//attestation_agent send app data to secure world to start an attestation
	new ~sessionID;
	[]--[]-> [TOSW(~sessionID,~deviceId,swId,nonce,packagename,~content,appSignature)];
	[ FROMSW(~sessionID,certificateChain) ]--[]-> [];
	out(certificateChain);

	in(<cipher,cipherContent>);
	
	[]--[]->[TOSW2(~sessionID,cipher)];
	[FROMSW2(~sessionID,<secretESk,signature>,hardwareMeasurement)]--[]->[]; 
	//no need to check verfication here, because it is ArbitraryApp
	event SecretOnlyReceivedAppStatus(~sessionID,secretESk,'invalid');
	let content = adec(cipherContent,secretESk) in 
	event SecretReceivedAppStatus(~sessionID,content,secretESk,'invalid');
	0


let ArbitraryAppInstallation =

	event Checked('ArbitraryAppInstallation');
	//install an application
	in(<packagename, devKey>); 

	new ~content;

	let appSignature = sign(devKey, <packagename,~content,pk(devKey)>) in
	let app = <packagename,~content,pk(devKey),appSignature> in
	out(app);
	event Arbitrary_App_Created(packagename,appSignature);
	event Application_Installed(~deviceId,packagename,~content,appSignature);

	!ArbitraryAppCode
	

let Device =

	//Create device reference
	new ~deviceId; 

	//send the device reference , allows an adversary to tamper the device
	out(~deviceId);
	
	//setup a secureWorld
	[]--[]-> [SetUPSW(~deviceId)];
	[FinishSetUPSW(~deviceId,swId)]--[]->[];
	event A_finished();

	(!HonestAppInstallation | !ArbitraryAppInstallation)


/***************************************** Knox V3 *****************************************/

let AtServerKA =
	new ~rootSk;
	let rootCertificate = create_certificate('TbsInfo',pk(~rootSk),~rootSk) in

	//share root certficate	
	[]--[]->
	[
		!RequestCreatingIntermediateCertificate(~rootSk,rootCertificate),
		!GetRootCertificate(rootCertificate)
	];

	!(
		event T_finish() 
	)


let KeyMasterTA =

	new ~swId; // We have different secure world and device ID, because it's possible to make different devices have the same ID, therefore 

	//setup a SecureWorld
	[SetUPSW(deviceId)]--[]->[FinishSetUPSW(deviceId,~swId)];

	
	//Request attestation server
	[!RequestCreatingIntermediateCertificate(rootSk,rootCertificate)]--[]->[];
	
	//Create keymaster certficate
	new ~keymasterSk;
	let  intermediateCertificate = create_certificate('TbsKeyStoreInfo',pk(~keymasterSk),rootSk) in

	//attempt to unlock bootloader
	in(attempt);

	!(
		//attestation_agent send app data to secure world, start an attestation
		[TOSW(sessionID, deviceId,~swId,nonce,packagename,content,appSignature)]--[]->[];

		new ~key;

		new ~atId;
		event Attestating_App(~atId,packagename,appSignature,deviceId);

		if(attempt = 'unlockBootloader') then
			let hardwareMeasurement = 'invalid' in
			//let softwareMeasurement = customSoftwareMeasurement in
			in(<fnonce,fpackagename,fappSignature>);	// adversary's custom softeware-based values
			let subjectCertificate = create_certificate(<~atId,hardwareMeasurement,nonce,packagename,appSignature>,pk(~key),~keymasterSk) in
			let certificateChain = <subjectCertificate, intermediateCertificate, rootCertificate> in 
			//send attestation report to the app
			event DeviceStatus(~atId,deviceId,hardwareMeasurement);
            event CreateCert(certificateChain);
			[]--[]->[ FROMSW(sessionID,certificateChain) ];

			[TOSW2(sessionID, aenc(<secretESk,signature>,pk(~key)))]--[]->[];
			event SecretReceived(secretESk);
			event SecretReceivedatDevice(sessionID,secretESk,hardwareMeasurement);
			[]--[]->[FROMSW2(sessionID,<secretESk,signature>,hardwareMeasurement)];

			event S_finish();
			0
		else
			let hardwareMeasurement = 'valid' in
			//let softwareMeasurement = 'valid' in
			let subjectCertificate = create_certificate(<~atId,hardwareMeasurement,nonce,packagename,appSignature>,pk(~key),~keymasterSk) in
			let certificateChain = <subjectCertificate, intermediateCertificate, rootCertificate> in 
			//send attestation report to the app
			event DeviceStatus(~atId,deviceId,hardwareMeasurement);
            event CreateCert(certificateChain);
			[]--[]->[ FROMSW(sessionID,certificateChain) ];

			[TOSW2(sessionID, aenc(<secretESk,signature>,pk(~key)))]--[]->[];
			event SecretReceived(secretESk);
			event SecretReceivedatDevice(sessionID,secretESk,hardwareMeasurement);
			[]--[]->[FROMSW2(sessionID,<secretESk,signature>,hardwareMeasurement)];

			event S_finish();
			0
	
			
	)



let DevServerProtocolCode =
	
		// create a nonce
		new ~nonce;
		event NonceGenerated(~nonce);
        new ~requestID;
        event RequestCert(~requestID);
		[]--[]-> [Nonce_Sent(~devId,~nonce)];
		out(~nonce);
		
		//retrieve blob from clients
		in(<<<atId,hardwareMeasurement,~nonce,fpackagename,fappSignature>,subjectPk,subjectChain>, intermediateCertificate, rootCertificate>);
		let subjectTbs = <atId,hardwareMeasurement,~nonce,fpackagename,fappSignature> in
		let subjectCertificate = <subjectTbs,subjectPk,subjectChain> in
		[!GetRootCertificate(rootCertificate)]--[]->[];
		
		let verification1 = verify_certificate(subjectCertificate, intermediateCertificate) in
		let verification2 = verify_certificate(intermediateCertificate, rootCertificate) in
		let verification3 = verify_certificate(rootCertificate, rootCertificate) in 

		//encrypt the secret encryption key
		let signature = sign(~secretESk,~secretVSk) in 
		let cipher = aenc(<~secretESk,signature>, subjectPk) in
		
		if(verification1 = verification2) & (verification1 = true) then		
			if (appSignature = fappSignature) & (packagename = fpackagename)  then
				event AcceptCert(~requestID,<subjectCertificate, intermediateCertificate, rootCertificate>);
				event Verdict_app(atId,hardwareMeasurement,'valid');
				event D_finish();
				if(hardwareMeasurement = 'valid') then
					out(cipher);
					0
				else
					0 
				
			else
				event Verdict_app(atId,hardwareMeasurement,'invalid');
				event D_finish() 



let DevServerKA =

	//generate secret
	new ~secretContent;
	event SecretContentGenerated(~secretContent);
	
	//secret verfication key
	new ~secretVSk;
	out(pk(~secretVSk));

	//secret encryption key
	new ~secretESk;
	out(pk(~secretESk));
	event SecretEKeyGenerated(~secretESk);

	event SecretGenerated(~secretContent,~secretESk);

	//generate cipher
	let cipherContent = aenc(<~secretContent>,pk(~secretESk)) in

	//creating and publishing the application
	new ~advk; // Dev server signing
	new ~devId; 
	let packagename = 'App1PackageName' in
	let content = <'App1Content',cipherContent,pk(~secretVSk)> in
	let appSignature = sign( <'App1PackageName',content,pk(~advk)>,~advk) in 
	let app = <'App1PackageName',content,pk(~advk),appSignature> in
	out(app);
	event App_Created('App1PackageName',appSignature);

	[]--[]-> [!App_Published(~devId,app)];
	


	!DevServerProtocolCode
/*************************************** Generic code *************************************************/
	
// Main process starts here

/***************************************** choose a platofrm ***************************************************
* platform				|		SafetyNet			|		KnoxV2		|	KnoxV3			|	Key Attestation
* --------------------------------------------------------------------------------------------------------------
* AttestationAgent		: GooglePlay | SafetyNetTA	|	KnoxV2TA		|	KnoxV3TA		|	KeyMasterTA
* AtServer				:		AtServerSN			|	AtServerKV2		|	AtServerKV3		|	AtServerKA
* DevServer				:		DevServerSN			|	DevServerKV2	|	DevServerKV3	|	DevServerKA
***************************************************************************************************************/


let AttestationAgent =
	KeyMasterTA

let AtServer = 
	AtServerKA

let DevServer = 
	DevServerKA




//create pair attetsation keys to be used by secreworld for sigining, and attestation server for verfication
new ~skAT;

(!Device || !DevServer || AtServer || !AttestationAgent )


lemma CertPossible:
  exists-trace 
    "Ex requestID subjectCertificate intermediateCertificate rootCertificate #i #j.
        (AcceptCert(requestID,<subjectCertificate, intermediateCertificate, rootCertificate>) @i
        & RequestCert(requestID)@j) & #j < #i "


lemma CertFresh:
    "All requestID subjectCertificate intermediateCertificate rootCertificate #i.
        AcceptCert(requestID,<subjectCertificate, intermediateCertificate, rootCertificate>) @i
            ==>   Ex #j. RequestCert(requestID)@j
			    & Ex #k. CreateCert (<subjectCertificate, intermediateCertificate, rootCertificate>)@k
			    & #j < #k & #k < #i" 





// for all valid attestation => (device must be not rooted and app must be not repacked).
lemma DeviceAndAppIntegrity:
	"(All atId #i. Verdict_app(atId,'valid','valid') @ i ==> 
	( 
	(Ex deviceId #j. DeviceStatus(atId,deviceId,'valid') @ j & j < i) 
	& (Ex deviceId packagename appSignature #j #k. 
			 App_Created(packagename,appSignature) @ j 
			 & Attestating_App(atId,packagename,appSignature,deviceId)@ k)
	))"


// for all failed application integrity check only  => (device must be valid and there an app created, an app attested and either the hash is different or packagename).
lemma RepackedAppIntegrity:
	"(All atId #i. Verdict_app(atId,'valid','invalid') @ i ==> 
	( 
	(Ex deviceId #j. DeviceStatus(atId,deviceId,'valid') @ j & j < i) 
	& (Ex deviceId packagename fpackagename appSignature fappSignature #j #k. 
			 App_Created(packagename,appSignature) @ j 
			 & Attestating_App(atId,fpackagename,fappSignature,deviceId)@ k
			 & (
					(not(appSignature = fappSignature))
					| (not(packagename = fpackagename))
			 	)
			 
		)
	))"

//Check if nonce are unique
lemma UniqueNonce:
	"All n #i #j. NonceGenerated(n) @i & NonceGenerated(n) @j ==> #i=#j"
	
//Sanity check: Attestation finished with valid device integirty and application integirty. 
lemma Correctness_Both_Valid:
exists-trace
	"Ex atId #i. Verdict_app(atId,'valid','valid') @ i"

//Sanity check: Attestation finished with at least failed device integirty
lemma Correctness_Rooting_Device:
exists-trace
	"Ex atId any #i. Verdict_app(atId,'invalid',any) @ i"

//Sanity check: Creation of an honest application 
lemma Correctness_Honest_App:
exists-trace
	"Ex #i. Checked('HonestAppInstallation') @ i"

//Sanity check: Creation of an arbitrary application 
lemma Correctness_Arbitrary_App:
exists-trace
	"Ex #i. Checked('ArbitraryAppInstallation') @ i"
	



lemma CorrectnessValidSecret:
	exists-trace
		"Ex secretContent secretESk  sessionID #i #j #k. SecretGenerated(secretContent,secretESk) @i & SecretReceivedatDevice(sessionID,secretESk,'valid')@j & SecretReceivedAppStatus(sessionID,secretContent,secretESk,'valid')@k & (#i<#j) & (#j<#k)"
	
lemma SecretValidity:
	all-traces
		"All secretContent secretESk  sessionID #j #k. SecretReceivedatDevice(sessionID,secretESk,'valid')@j & SecretReceivedAppStatus(sessionID,secretContent,secretESk,'valid')@k ==>
		(Ex #i. SecretGenerated(secretContent,secretESk) @i & (#i<#j) & (#j<#k))"
	

lemma SecretSecrecy:
	all-traces
		"All secretContent secretESk  #i. SecretGenerated(secretContent,secretESk) @i ==> 
		(not(Ex #k. KU(<secretContent,secretESk>)@k & (#i<#k)))
		& (not(Ex sessionID #k. SecretReceivedAppStatus(sessionID,secretContent,secretESk,'invalid')@k  & (#i<#k) ))
		& (not(Ex sessionID #j. SecretReceivedatDevice(sessionID,secretESk,'invalid')@j & (#i<#j)))"
	
//Desc: Doliv-yao should not be able to know secrets generated by an honest developer
//For all secrets, generated by an honest developer, then there is no exist an advsery know at least one of these secrets.
lemma SecretSecrecyKU:
	all-traces
		"All secretContent secretESk #i. SecretGenerated(secretContent,secretESk) @i ==> (not(Ex #k. KU(<secretContent,secretESk>)@k & (#i<#k)))"

//Desc: Repacked app should not be able to know secrets generated by an honest developer
//For all secrets, generated by an honest developer, and receved by a valid device => then, there is no exist a secret recvied by an arbitrary app.
lemma SecretSecrecyAgainstRepakedApp:
	all-traces
		"All secretContent secretESk #i . SecretGenerated(secretContent,secretESk) @i  ==>
			(not(Ex sessionID #k. SecretReceivedAppStatus(sessionID,secretContent,secretESk,'invalid')@k  & (#i<#k) ))"

//Desc: Rooted device should not be able to know secrets generated by an honest developer
//For all traces, it is not possibile for a secret generated by an honest developer to be retrieved/known/leaked by a rooted device.
lemma SecretSecrecyAgainstRootedDevice:
	all-traces
		"All secretContent secretESk  #i. SecretGenerated(secretContent,secretESk) @i ==> (not(Ex sessionID #j. SecretReceivedatDevice(sessionID,secretESk,'invalid')@j & (#i<#j)))"



//Desc: KU advseray should not be able to inject key into an honest app that run on an honest device 
//For all secrets that recieved by a valid device and loaded by an honest app to be known by adversary
lemma KeyInjection:
	all-traces
		"All  secretESk sessionID #i #k.SecretReceivedatDevice(sessionID,secretESk,'valid')@i &  KU(secretESk) @k  ==>
			(not(Ex #j. SecretOnlyReceivedAppStatus(sessionID,secretESk,'valid')@j & (#i<#j)))"



//can rooted device, inecjt valid app? yes becuase the device rooted. full control over everything
// Code injection on rooted device : It is a possibile for a remote advsery to inject a key intro an honest app  if the device under the attacker control.
lemma KeyInjectionByRootedDevice:
exists-trace
		"(Ex  secretESk sessionID #i #j #k. SecretReceivedatDevice(sessionID,secretESk,'invalid')@i & SecretOnlyReceivedAppStatus(sessionID,secretESk,'valid')@j & KU(secretESk)@k  & (#i<#j))"

end

==============================================================================
summary of summaries:

analyzed: KeyAttestation_App_Code_Protection_Key.sapic

  CertPossible (exists-trace): verified (13 steps)
  CertFresh (all-traces): verified (258 steps)
  DeviceAndAppIntegrity (all-traces): verified (432 steps)
  RepackedAppIntegrity (all-traces): verified (862 steps)
  UniqueNonce (all-traces): verified (8 steps)
  Correctness_Both_Valid (exists-trace): verified (13 steps)
  Correctness_Rooting_Device (exists-trace): verified (16 steps)
  Correctness_Honest_App (exists-trace): verified (4 steps)
  Correctness_Arbitrary_App (exists-trace): verified (4 steps)
  CorrectnessValidSecret (exists-trace): verified (17 steps)
  SecretValidity (all-traces): verified (14 steps)
  SecretSecrecy (all-traces): verified (2511 steps)
  SecretSecrecyKU (all-traces): verified (238 steps)
  SecretSecrecyAgainstRepakedApp (all-traces): verified (1374 steps)
  SecretSecrecyAgainstRootedDevice (all-traces): verified (900 steps)
  KeyInjection (all-traces): verified (1122 steps)
  KeyInjectionByRootedDevice (exists-trace): verified (9 steps)
==============================================================================
