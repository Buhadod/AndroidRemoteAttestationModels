/*******************************************************************************
	Remote attestation Framework
	AUTHORS
	
	
*******************************************************************************/

theory Framework_SafetyNetHW
begin

builtins: signing, asymmetric-encryption, locations-report

heuristic: S


predicates:
Report(x,y) <=> not  (fst(y)= 'loc')
      


/***************************************** Generic *****************************************/

let AppCode = 
	[Nonce_Sent(devId,nonce)]--[]-> [];

	event NonceReceived(nonce);

	//attestation_agent send app data to secure world to start an attestation
	new ~sessionID;
	[]--[]-> [TOSW(~sessionID,~deviceId,swId,nonce,'App1PackageName','App1Content',sign(<'App1PackageName','App1Content',pk(advk)>,advk))];
	[ FROMSW(~sessionID,blob) ]--[]-> [];

	[]--[]-> [Blob_Sent(blob)];
	0

let HonestAppInstallation =
	event Checked('HonestAppInstallation');
	//install an application
	[!App_Published(devId,<'App1PackageName','App1Content',pk(advk),
	                   sign(<'App1PackageName','App1Content',pk(advk)>,advk)>)]--[]-> [];

	event Application_Installed(~deviceId,'App1PackageName','App1Content',sign(<'App1PackageName','App1Content',pk(advk)>,advk));

	!AppCode //App code separate from installation 

let ArbitraryAppCode =
	in(nonce);
	event NonceReceived(nonce);
	//attestation_agent send app data to secure world to start an attestation
	new ~sessionID;
	[]--[]-> [TOSW(~sessionID,~deviceId,swId,nonce,packagename,~content,appSignature)];
	[ FROMSW(~sessionID,blob) ]--[]-> [];
	out(blob);
	0

let ArbitraryAppInstallation =
	event Checked('ArbitraryAppInstallation');
	//install an application
	in(<packagename, devKey>); //Attacker can pick the app name and the dev key.

	new ~content;  //contents are different from any honest app, so we model as a free name

	let appSignature = sign(<packagename,~content,pk(devKey)>,devKey) in
	let app = <packagename,~content,pk(devKey),appSignature> in
	out(app);
	event Arbitrary_App_Created(packagename,appSignature);
	event Application_Installed(~deviceId,packagename,~content,appSignature);

	!ArbitraryAppCode

let Device =

	//Create device reference
	new ~deviceId;   

	//send the device reference , allows an adversary to tamper the device
	out(~deviceId);
	
	//setup a secureWorld
	[]--[]-> [SetUPSW(~deviceId)];
	[FinishSetUPSW(~deviceId,swId)]--[]->[];
	event A_finished();

	(!HonestAppInstallation | !ArbitraryAppInstallation) 

let RelayAttacker1 = 
	[Nonce_Sent(devId,nonce)]--[]-> [];
	out(nonce);
	0

let RelayAttacker2 = 
	in(blob);
	[]--[]-> [Blob_Sent(blob)];
	0

/***************************************** SafetyNetHW *****************************************/

let AtServerSN =
	!(

		//retrieve the blob from the developer server and verify it
        [TOAT(sid,<atId,nonce,hardwareMeasurement,packagename,appSignature,report,sign(report,~skAT)>)]--[]-> []; 

		if <atId,nonce,hardwareMeasurement,packagename,appSignature> =  check_rep(report,<'loc',pk(~skAT)>) then
			//create a verdict  and send it to the developer server
			let verdict = 'valid' in
			[]--[]-> [FRAT(sid,verdict)];
			event T_finish();
			0 
			

		else
			//create a verdict  and send it to the developer server
			let verdict = 'invalid' in
			[]--[]-> [FRAT(sid,verdict)];
			event T_finish();
			0
	)


let SafetyNetTA =

	(
	new ~swId; // We have different secure world and device ID, because it's possible to make different devices have the same ID, therefore 

	//setup a SecureWorld
	[SetUPSW(deviceId)]--[]->[FinishSetUPSW(deviceId,~swId)];

	//attempt to unlock bootloader
	in(attempt);

	!(
		//attestation_agent send app data to secure world, start an attestation
		[TOSW(sessionID, deviceId,~swId,nonce,packagename,content,appSignature)]--[]->[];

		new ~atId; // attestation id
		event Attestating_App(~atId,packagename,appSignature,deviceId);

		if attempt = 'unlockBootloader' then
			let hardwareMeasurement = 'invalid' in
			// Software measurment not used in HW attestation
			//in(customSoftwareMeasurement);
			//let softwareMeasurement =  customSoftwareMeasurement in
			in(<fnonce,fpackagename,fappSignature>);	// adversary's custom softeware-based values
			let report = report(<~atId,fnonce,hardwareMeasurement,fpackagename,fappSignature>) in 
			let blob = <~atId, fnonce, hardwareMeasurement,fpackagename,fappSignature, report,sign(report,~skAT)> in
			out(blob);

			///return attestation report to the app
			event DeviceStatus(~atId,deviceId,hardwareMeasurement);
			[]--[]->[ FROMSW(sessionID,blob) ];
			event S_finish();
			0
		else
			let hardwareMeasurement = 'valid' in
			let report = report(<~atId,nonce,hardwareMeasurement,packagename,appSignature>) in 
			let blob = <~atId,nonce,hardwareMeasurement,packagename,appSignature,report,sign(report,~skAT)> in
			///return attestation report to the app
			event DeviceStatus(~atId,deviceId,hardwareMeasurement);
			[]--[]->[ FROMSW(sessionID,blob) ];
			event S_finish();
			0
			
	)
	)@<'loc',pk(~skAT)>

let DevServerProtocolCode =
	// create a nonce
	new ~nonce;
	event NonceGenerated(~nonce);
	[]--[]-> [Nonce_Sent(~devId,~nonce)];

	//retrieve blob from clients
	[Blob_Sent(<atId,~nonce,hardwareMeasurement,fpackagename,fappSignature,report,reportSignature>)]--[]->[];
	let blob = <atId,~nonce,hardwareMeasurement,fpackagename,fappSignature,report,reportSignature> in

	//create developer-attestation server session id, to keep track or pair of request-response message  
	new ~sid;
	[]--[]-> [TOAT(~sid,blob)];	// securely send blob to the attestation server

	//retrieve the verfied report the attestation server, pattern matching is used for checking the status
	[FRAT(~sid,verdict)]--[]-> [];
		

	//attestation finished		
	if appSignature = fappSignature then
		if packagename = fpackagename  then
			event Verdict_app(atId,blob,verdict,hardwareMeasurement,'valid');
			event D_finish() 
		else
			event Verdict_app(atId,blob,verdict,hardwareMeasurement,'invalid');
			event D_finish() 
	else
		event Verdict_app(atId,blob,verdict,hardwareMeasurement,'invalid');
		event D_finish() 


let DevServerSN =

	//creating and publishing the application
	new ~advk; // Dev server signing
	new ~devId; 

	let packagename = 'App1PackageName' in
	let appSignature = sign(<packagename,'App1Content',pk(~advk)>,~advk) in 
	let app = <packagename,'App1Content',pk(~advk),appSignature> in
	out(app);
	event App_Created(packagename,appSignature);

	[]--[]-> [!App_Published(~devId,app)];
	
	!DevServerProtocolCode

/*************************************** Generic code *************************************************/
	
// Main process starts here

/***************************************** choose a platform ***************************************************
* platform				|		SafetyNet			|		KnoxV2		|	KnoxV3			|	Key Attestation
* --------------------------------------------------------------------------------------------------------------
* AttestationAgent		: GooglePlay | SafetyNetTA	|	KnoxV2TA		|	KnoxV3TA		|	KeyMasterTA
* AtServer				:		AtServerSN			|	AtServerKV2		|	AtServerKV3		|	AtServerKA
* DevServer				:		DevServerSN			|	DevServerKV2	|	DevServerKV3	|	DevServerKA
***************************************************************************************************************/


let AttestationAgent =
	SafetyNetTA

let AtServer = 
	AtServerSN

let DevServer = 
	DevServerSN



//create pair attestation keys to be used by secureWorld for signing, and attestation server for verification
new ~skAT;

(!Device || !DevServer || AtServer || !AttestationAgent || !RelayAttacker1 || !RelayAttacker2)

// for all valid attestation => (device must be not rooted and app must be not repacked).
// lemma DeviceAndAppIntegrity:
// 	"(All atId blob #i. Verdict_app(atId,blob,'valid','valid','valid') @ i ==> 
// 	( 
// 	(Ex deviceId #j. DeviceStatus(atId,deviceId,'valid') @ j & j < i) 
// 	& (
// 		Ex deviceId packagename appSignature #a #b. 
// 				App_Created(packagename,appSignature) @ a 
// 				& Attestating_App(atId,packagename,appSignature,deviceId)@ b
// 				& not( Ex #k. KU(blob) @ k ) 
// 		)
// 	))"

lemma DeviceAndAppIntegrity:
	"(All atId blob #i. Verdict_app(atId,blob,'valid','valid','valid') @ i ==> 
	 (	not( Ex #k. KU(blob) @ k & k<i ) )
	)"

// for all failed application integrity check only  => (device must be valid and there an app created, an app attested and either the hash is different or packagename).
// lemma RepackedAppIntegrity:
// 	"(All atId #i. Verdict_app(atId,'valid','invalid') @ i ==> 
// 	( 
// 	(Ex deviceId #j. DeviceStatus(atId,deviceId,'valid') @ j & j < i) 
// 	& (Ex deviceId packagename fpackagename appSignature fappSignature #j #k. 
// 			 App_Created(packagename,appSignature) @ j 
// 			 & Attestating_App(atId,fpackagename,fappSignature,deviceId)@ k
// 			 & (
// 					(not(appSignature = fappSignature))
// 					| (not(packagename = fpackagename))
// 			 	)
			 
// 		)
// 	))"

// Check if nonce are unique 
lemma UniqueNonce:
	"All n #i #j. NonceGenerated(n) @i & NonceGenerated(n) @j ==> #i=#j"
	
//Sanity check: Attestation finished with valid device integirty and application integirty. 
// lemma Correctness_Both_Valid:
// exists-trace
// 	"Ex atId #i. Verdict_app(atId,'valid','valid') @ i"

// //Sanity check: Attestation finished with at least failed device integirty
// lemma Correctness_Rooting_Device:
// exists-trace
// 	"Ex atId any #i. Verdict_app(atId,'invalid',any) @ i"

//Sanity check: Creation of an honest application 
lemma Correctness_Honest_App:
exists-trace
	"Ex #i. Checked('HonestAppInstallation') @ i"

//Sanity check: Creation of an arbitrary application 
lemma Correctness_Arbitrary_App:
exists-trace
	"Ex #i. Checked('ArbitraryAppInstallation') @ i"
	
end

==============================================================================
summary of summaries:

analyzed: SafetyNetHW.sapic

	DeviceAndAppIntegrity (all-traces): verified (8 steps)
	RepackedAppIntegrity (all-traces): verified (9 steps)
	UniqueNonce (all-traces): verified (8 steps)
	Correctness_Both_Valid (exists-trace): verified (7 steps)
	Correctness_Rooting_Device (exists-trace): verified (7 steps)
	Correctness_Honest_App (exists-trace): verified (4 steps)
	Correctness_Arbitrary_App (exists-trace): verified (4 steps)

==============================================================================
