/*******************************************************************************
	Remote attestation Framework
	AUTHORS
	
	
*******************************************************************************/

theory Framework_KnoxV2
begin

builtins: signing, asymmetric-encryption

functions: check_rep/2,  get_rep/1, rep/2 [private], create_certificate/3, verify_certificate/2 , get_tbsInfo_certificate/1

equations:
    check_rep(rep(x.1, x.2), x.2) = true,
    get_rep(rep(x.1, x.2)) = x.1,

    create_certificate(SubjectTBSCertificateInfo,SubjectPup,IssuerSk) 
      = < SubjectTBSCertificateInfo, SubjectPup, sign(<SubjectTBSCertificateInfo, SubjectPup>,IssuerSk) >,

    verify_certificate( 
    < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
     , < IssuerTBSCertificateInfo, pk(IssuerSk), sign(<IssuerTBSCertificateInfo, pk(IssuerSk)>,IssuerRootSk) >
          ) = true,

    get_tbsInfo_certificate( 
        < SubjectTBSCertificateInfo, pk(SubjectSk), sign(<SubjectTBSCertificateInfo, pk(SubjectSk)>,IssuerSk) >
          ) = SubjectTBSCertificateInfo
      


/***************************************** Generic *****************************************/

let AppCode = 
	[Nonce_Sent(devId,nonce)]--[]-> [];

	event NonceReceived(nonce);

	//attestation_agent send app data to secure world to start an attestation
	new ~sessionID;
	[]--[]-> [TOSW(~sessionID,~deviceId,swId,nonce,packagename,'App1Content',appSignature)];
	[ FROMSW(~sessionID,blob) ]--[]-> [];
	out(blob);
	0

let HonestAppInstallation =
	event Checked('HonestAppInstallation');
	//install an application
	[!App_Published(devId,packagename,'App1Content',appSignature)]--[]-> [];

	event Application_Installed(~deviceId,packagename,'App1Content',appSignature);

	!AppCode // TOM: App code separate from installation 


let ArbitraryAppCode =
	in(nonce);
	event NonceReceived(nonce);
	//attestation_agent send app data to secure world to start an attestation
	new ~sessionID;
	[]--[]-> [TOSW(~sessionID,~deviceId,swId,nonce,packagename,~content,appSignature)];
	[ FROMSW(~sessionID,blob) ]--[]-> [];
	out(blob);
	0

let ArbitraryAppInstallation =
	event Checked('ArbitraryAppInstallation');
	//install an application
	in(<packagename, devKey>); //TOM Attacker can pick the app name and the dev key.
	//REMOVED: new ~hash;
	//REMOVED: let appSignature = ~hash in

	new ~content;  //TOM: contents are different from any honest app, so we model as a free name

	let appSignature = sign(devKey, <packagename,~content>) in
	let app = <packagename,~content,appSignature> in
	out(app);
	event Arbitrary_App_Created(packagename,appSignature);
	event Application_Installed(~deviceId,packagename,~content,appSignature);

	!ArbitraryAppCode

// Removed to make a little neater
//let AppInstallation =
//	(HonestAppInstallation + ArbitraryAppInstallation)

let Device =

	//Create device reference
	new ~deviceId;   // TOM: Is the device ID secure?

	//send the device reference , allows an adversary to tamper the device
	out(~deviceId);
	
	let status = 'valid' in
	//setup a secureWorld
	[]--[]-> [SetUPSW(~deviceId,status)];
	[FinishSetUPSW(~deviceId,swId)]--[]->[];
	event A_finished();

	(!HonestAppInstallation | !ArbitraryAppInstallation) //TOM


/***************************************** Knox V3 *****************************************/

let AtServerKV2 =
	!(

		//retrieve the blob from the developer server and verify it
        [TOAT(sid,rep(<atId,hardwareMeasurement,nonce, deviceId>,<~skAT,'Trustzone'>))]--[]-> [];

		//create a verdict  and send it to the developer server
		let verdict = <atId,hardwareMeasurement,nonce, deviceId> in
        []--[]-> [FRAT(sid,verdict)];

		event T_finish() 
	)

let UnlockBootloader =
	[SetUPSW(deviceId,status)]--[]->[];
	if not(status = 'tamper') then
		[]--[]->[SetUPSW(deviceId,'tamper')];
		0

let KnoxV2TA =

	new ~swId; // We have different secure world and device ID, because it's possible to make different devices have the same ID, therefore 

	//setup a SecureWorld
	[SetUPSW(deviceId,status)]--[]->[FinishSetUPSW(deviceId,~swId)];
	
	//retrieve an adversary's attempt to compromised the device
	//[!BootloaderStatus(status,customSoftwareMeasurement)]--[]->[];


	!(
		//attestation_agent send app data to secure world, start an attestation
		[TOSW(sessionID, deviceId,~swId,nonce,packagename,content,appSignature)]--[]->[];

		new ~atId; // attestation id
		event Attestating_App(~atId,packagename,appSignature,deviceId);

		if(status = 'tamper') then
			let hardwareMeasurement = 'invalid' in
			// Software measurment not used in Knox
			//in(customSoftwareMeasurement);
			//let softwareMeasurement =  customSoftwareMeasurement in
			let blob = rep(<~atId,hardwareMeasurement,nonce, deviceId>,<~skAT,'Trustzone'>) in 
			///send attestation report to the attestation server
			event DeviceStatus(~atId,deviceId,hardwareMeasurement);
			[]--[]->[ FROMSW(sessionID,blob) ];
			event S_finish();
			0
		else
			let hardwareMeasurement = 'valid' in
			//let softwareMeasurement = 'valid' in
			let blob = rep(<~atId,hardwareMeasurement,nonce, deviceId>,<~skAT,'Trustzone'>) in 
			///send attestation report to the attestation server
			event DeviceStatus(~atId,deviceId,hardwareMeasurement);
			[]--[]->[ FROMSW(sessionID,blob) ];
			event S_finish();
			0
			
	)


let DevServerKV2 =

	//creating and publishing the application
	new ~advk;
	// new ~content; REMOVED
	new ~packagename;
	let appSignature = sign(~advk, <~packagename,'App1Content'>) in //TOM: Why is this never checked?
	let app = <~packagename,'App1Content',appSignature> in
	out(app);
	event App_Created(~packagename,appSignature);

	new ~devId;
	[]--[]-> [!App_Published(~devId,~packagename,'App1Content',appSignature)];
	!(
	
		// create a nonce
		new ~nonce;
		event NonceGenerated(~nonce);
		[]--[]-> [Nonce_Sent(~devId,~nonce)];
		out(~nonce);
		
		//retrieve blob from clients
		in(blob);
		
		//create developer-attestation server session id, to keep track or pair of request-response message  
		new ~sid;
		//send blob to the attestation server
		[]--[]-> [TOAT(~sid,blob)];
		
		//retrieve the verified report the attestation server, pattern matching is used for checking the status
		[FRAT(~sid,<atId,hardwareMeasurement,~nonce, deviceId>)]--[]-> [];
		
		//attestation finished	//because measurement miss app info. so we assume always invalid	
		event Verdict_app(atId,deviceId,hardwareMeasurement,'invalid'); 
		0


	)

/*************************************** Generic code *************************************************/
	
// Main process starts here

/***************************************** choose a platform ***************************************************
* platform				|		SafetyNet			|		KnoxV2		|	KnoxV3			|	Key Attestation
* --------------------------------------------------------------------------------------------------------------
* AttestationAgent		: GooglePlay | SafetyNetTA	|	KnoxV2TA		|	KnoxV3TA		|	KeyMasterTA
* AtServer				:		AtServerSN			|	AtServerKV2		|	AtServerKV3		|	AtServerKA
* DevServer				:		DevServerSN			|	DevServerKV2	|	DevServerKV3	|	DevServerKA
***************************************************************************************************************/


let AttestationAgent =
	KnoxV2TA

let AtServer = 
	AtServerKV2

let DevServer = 
	DevServerKV2



//create pair attestation keys to be used by secureWorld for signing, and attestation server for verification
new ~skAT;

(!Device || !DevServer || AtServer || !AttestationAgent || UnlockBootloader)

// for all valid attestation => (device must be not rooted and app must be not repacked).
lemma DeviceAndAppIntegrity:
	"(All atId deviceId a #i. Verdict_app(atId,deviceId,'valid',a) @ i ==> 
	( 
	(Ex #j. DeviceStatus(atId,deviceId,'valid') @ j & j < i) 
	& (Ex packagename appSignature #j #k. 
			 App_Created(packagename,appSignature) @ j 
			 & Attestating_App(atId,packagename,appSignature,deviceId)@ k)
	))"


// for all failed application integrity check only  => (device must be valid and there an app created, an app attested and either the hash is different or packagename).
lemma RepackedAppIntegrity:
	"(All atId deviceId #i. Verdict_app(atId,deviceId,'valid','invalid') @ i ==> 
	( 
	(Ex #j. DeviceStatus(atId,deviceId,'valid') @ j & j < i) 
	& (Ex packagename fpackagename appSignature fappSignature #j #k. 
			 App_Created(packagename,appSignature) @ j 
			 & Attestating_App(atId,fpackagename,fappSignature,deviceId)@ k
			 & (
					(not(appSignature = fappSignature))
					| (not(packagename = fpackagename))
			 	)
			 
		)
	))"

lemma UniqueNonce:
	"All n #i #j. NonceGenerated(n) @i & NonceGenerated(n) @j ==> #i=#j"
	
//Sanity check: Attestation finished
lemma Correctness_Both_Valid:
exists-trace
	"Ex atId deviceId #i. Verdict_app(atId,deviceId,'valid','valid') @ i"

//Sanity check: Attestation finished
lemma Correctness_Rooting_Device:
exists-trace
	"Ex atId any deviceId #i. Verdict_app(atId,deviceId,'invalid',any) @ i"


lemma Correctness_TV:
exists-trace
	"Ex #i. Checked('HonestAppInstallation') @ i"

lemma Correctness_TI:
exists-trace
	"Ex #i. Checked('ArbitraryAppInstallation') @ i"
	
end